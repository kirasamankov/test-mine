<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Block Bonus ‚Äì Your Style</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    html,body{height:100%;margin:0;background:#79d0ff;overflow:hidden}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:10px}
    canvas{
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius: 18px;
      box-shadow: 0 30px 90px rgba(0,0,0,.35);
      outline: 2px solid rgba(0,0,0,.25);
      background:#79d0ff;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>
<body>
<div id="wrap"></div>

<script>
(() => {
  // ===== –ü–ê–†–ê–ú–ï–¢–†–´ =====
  const FREE_SPINS = 4;

  const CHESTS_TOTAL = 5;
  const OPEN_MIN = 3, OPEN_MAX = 5; // –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è 3..5

  const DECIMALS = 2; // –∏—Ç–æ–≥ —Å —Ç–æ—á–∫–æ–π: 327.00
  const BET_MIN = 10, BET_MAX = 5000, BET_STEP = 10;

  // ===== CANVAS (9:16) =====
  const W = 360, H = 640;

  // ===== LAYOUT =====
  const PANEL_TOP = { x: 64, y: 26, w: 232, h: 128, cols:5, rows:3 };

  // ‚Äú–ë–ê–®–ù–Ø‚Äù –∏–∑ –±–ª–æ–∫–æ–≤ (5 –∫–æ–ª–æ–Ω–æ–∫), –∫–æ–º–ø–∞–∫—Ç–∏—Ç—Å—è –≤–Ω–∏–∑
  const TOWER = { x: 120, baseY: 476, colW: 24, cell: 24, cols: 5 };
  const START_HEIGHTS = [6,5,6,5,6];

  // –°—É–Ω–¥—É–∫–∏
  const CHEST = { y: 500, w: 44, h: 44, gap: 6, startX: 60 };

  // –ò—Ç–æ–≥–æ–≤–∞—è –ø–ª–∞—à–∫–∞
  const SLAB = { x: 86, y: 560, w: 188, h: 32 };

  // UI –ø–∞–Ω–µ–ª—å
  const UI_Y = H - 22;

  // –¢–∞–π–º–∏–Ω–≥–∏
  const REEL_SPIN_MS = 650;
  const OVERLAY_MS = 900;
  const BETWEEN_SPINS_MS = 240;
  const HIT_DELAY_MS = 110;
  const CHEST_STEP_MS = 420;

  // ===== SYMBOLS (–∫–∏—Ä–∫–∏ + TNT) =====
  const SYMS = [
    { k:"P1", hits:1 },
    { k:"P2", hits:2 },
    { k:"P3", hits:3 },
    { k:"TNT",hits:5 },
  ];

  // ===== BLOCK TYPES (–ø–∏–∫—Å–µ–ª—å–Ω—ã–µ) =====
  const BLOCKS = {
    STONE: { key:"STONE", hp:1, pay:0.15, base:0xd8d8d8, speck:0xa7a7a7 },
    RED:   { key:"RED",   hp:1, pay:0.30, base:0xdedede, speck:0xc93a3a },
    DIAM:  { key:"DIAM",  hp:1, pay:0.70, base:0x57e9ff, speck:0x2fb9d2 },
    GOLD:  { key:"GOLD",  hp:1, pay:0.55, base:0xffd85a, speck:0xeab021 },
    OBSI:  { key:"OBSI",  hp:2, pay:1.50, base:0x1c1630, speck:0x2f2850 },
  };

  // ===== Phaser Game (CANVAS ‚Äî —á—Ç–æ–±—ã —Ç–æ—á–Ω–æ –Ω–µ –±—ã–ª–æ —á—ë—Ä–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞) =====
  new Phaser.Game({
    type: Phaser.CANVAS,
    parent: "wrap",
    width: W,
    height: H,
    backgroundColor: "#79d0ff",
    pixelArt: true,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: { create, update }
  });

  // ===== STATE =====
  let s;
  let running=false, recMode=false;

  let bet=100;
  let total=0, totalDisp=0;
  let spinIdx=0;

  // top panel
  let panelCells=[];
  let panelG;

  // tower
  let towerCols=[];
  let towerSprites=[];

  // chests
  let chests=[];

  // texts/ui
  let slabText, fsText, overlayC, uiC;

  function create(){
    s=this;

    drawSky();
    drawGround();

    drawTopPanel();
    buildTopCells();

    initTower();
    redrawTower();

    buildChests();
    drawSlab();

    buildOverlay();
    buildUI();
    setupRECControls();

    setTotal(0);
    randomizePanel(true);
  }

  function update(){
    totalDisp += (total-totalDisp)*0.18;
    if(Math.abs(total-totalDisp)<0.005) totalDisp=total;
    slabText.setText(fmt(totalDisp));
  }

  // ================= FLOW =================
  async function startBonus(){
    if(running) return;
    running=true;
    lockUI(true);

    spinIdx=0;
    setTotal(0);
    resetChests();

    initTower();
    redrawTower();

    overlayC.show();
    await wait(OVERLAY_MS);
    overlayC.hide();
    await wait(240);

    for(let i=0;i<FREE_SPINS;i++){
      spinIdx=i+1;
      fsText.setText(`FREE SPIN ${spinIdx}/${FREE_SPINS}`);
      await doSpin();
      await wait(BETWEEN_SPINS_MS);
    }
    fsText.setText("");

    await doChestPhase();

    running=false;
    lockUI(false);
  }

  async function doSpin(){
    await reelSpin();

    const hits=[0,0,0,0,0];
    panelCells.forEach(cell=> hits[cell.c] += cell.sym.hits);
    for(let i=0;i<5;i++) hits[i] += rndi(0,2);

    for(let c=0;c<5;c++){
      let left=hits[c];
      while(left>0){
        const ok = hitTopBlockInColumn(c);
        if(!ok) break;
        left--;
        await wait(HIT_DELAY_MS);
      }
    }
    redrawTower();
  }

  function hitTopBlockInColumn(col){
    const stack = towerCols[col].blocks;
    if(stack.length===0) return false;

    const b = stack[stack.length-1];
    b.hp -= 1;

    const p = blockToWorld(col, stack.length-1);
    burst(p.x+12, p.y+12, b.type.speck);

    if(b.hp<=0){
      stack.pop();
      const add = bet * b.type.pay;
      setTotal(total + add);
      floatWin(p.x+12, p.y-6, add);
      return true;
    }
    return true;
  }

  async function doChestPhase(){
    const openCount = rndi(OPEN_MIN, OPEN_MAX+1);

    const pool = (openCount===3)
      ? {v:[5,10,12,15,20,25,30,40,50], w:[6,14,14,14,14,12,10,8,8]}
      : (openCount===4)
      ? {v:[2,3,5,8,10,12,15,20,25], w:[18,16,16,14,12,10,8,4,2]}
      : {v:[2,2,3,3,5,5,8,10,12], w:[22,20,16,14,12,8,5,2,1]};

    const order=[0,1,3,4,2]; // —Ü–µ–Ω—Ç—Ä –ø–æ—Å–ª–µ–¥–Ω–∏–º (–∫–∞–∫ –≤ —Ç–≤–æ—ë–º –∫–∞–¥—Ä–µ)
    let opened=0;
    let cur=total;

    for(const idx of order){
      if(opened>=openCount) break;

      // —Ü–µ–Ω—Ç—Ä —á–∞—â–µ –æ—Å—Ç–∞—ë—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—ã–º –µ—Å–ª–∏ openCount<5
      if(idx===2 && openCount<5 && Math.random()<0.75) continue;

      const mul = pickW(pool.v, pool.w);
      openChest(idx);
      showMul(idx, mul);

      cur = cur * mul;
      setTotal(cur);

      opened++;
      await wait(CHEST_STEP_MS);
    }

    // –¥–æ–±–∏–≤–∞–µ–º, –µ—Å–ª–∏ –∏–∑-–∑–∞ –ø—Ä–æ–ø—É—Å–∫–∞ —Ü–µ–Ω—Ç—Ä–∞ –Ω–µ —Ö–≤–∞—Ç–∏–ª–æ
    if(opened<openCount){
      for(const idx of [0,4,1,3,2]){
        if(opened>=openCount) break;
        if(chests[idx].open) continue;

        const mul = pickW(pool.v, pool.w);
        openChest(idx);
        showMul(idx, mul);

        cur = cur * mul;
        setTotal(cur);

        opened++;
        await wait(CHEST_STEP_MS);
      }
    }

    setTotal(makeNice(cur));
    await wait(300);
  }

  // ================= VISUALS =================
  function drawSky(){
    s.add.rectangle(W/2,H/2,W,H,0x79d0ff).setDepth(-50);
    for(let i=0;i<8;i++) cloud(rndi(10,W-70), rndi(20,200), rndi(22,40));
  }

  function cloud(x,y,size){
    const g=s.add.graphics().setDepth(-40);
    g.fillStyle(0xffffff,1);
    g.fillRect(x,y,size,size/2);
    g.fillRect(x+10,y-6,size,size/2);
    g.fillRect(x+22,y+2,size,size/2);
    g.fillStyle(0x000000,0.06);
    g.fillRect(x,y+size/2-2,size+22,3);
  }

  function drawGround(){
    const g=s.add.graphics().setDepth(-30);
    g.fillStyle(0x5fd23f,1); g.fillRect(0,520,W,14);
    g.fillStyle(0xb8743c,1); g.fillRect(0,534,W,106);
    g.fillStyle(0x000000,0.08); g.fillRect(0,520,W,120);
  }

  function drawTopPanel(){
    const {x,y,w,h,cols,rows}=PANEL_TOP;
    panelG=s.add.graphics();

    panelG.fillStyle(0xd0d0d0,1); panelG.fillRect(x,y,w,h);
    panelG.lineStyle(3,0x6b6b6b,1); panelG.strokeRect(x,y,w,h);
    panelG.lineStyle(2,0x8d8d8d,1); panelG.strokeRect(x+2,y+2,w-4,h-4);

    const cw=Math.floor(w/cols), ch=Math.floor(h/rows);

    panelG.lineStyle(2,0xffffff,0.9);
    for(let c=1;c<cols;c++){
      panelG.beginPath(); panelG.moveTo(x+c*cw,y+6); panelG.lineTo(x+c*cw,y+h-6); panelG.strokePath();
    }
    for(let r=1;r<rows;r++){
      panelG.beginPath(); panelG.moveTo(x+6,y+r*ch); panelG.lineTo(x+w-6,y+r*ch); panelG.strokePath();
    }
  }

  function buildTopCells(){
    panelCells=[];
    const {x,y,w,h,cols,rows}=PANEL_TOP;
    const cw=Math.floor(w/cols), ch=Math.floor(h/rows);

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cx=x+c*cw, cy=y+r*ch;
        const cont=s.add.container(cx+cw/2, cy+ch/2);
        panelCells.push({r,c,cx,cy,cw,ch,cont,sym:SYMS[0]});
      }
    }
  }

  function randomizePanel(forceTNT){
    panelCells.forEach(cell=>{
      const sym = forceTNT && cell.r===0 && cell.c===1
        ? SYMS.find(z=>z.k==="TNT")
        : pickW([SYMS[0],SYMS[1],SYMS[2],SYMS[3]],[26,30,28,16]);
      cell.sym=sym;
      drawPanelIcon(cell);
    });
  }

  function drawPanelIcon(cell){
    cell.cont.removeAll(true);

    if(cell.sym.k==="TNT"){
      const g=s.add.graphics();
      g.fillStyle(0xd83b3b,1); g.fillRect(-14,-14,28,28);
      g.fillStyle(0xffffff,1); g.fillRect(-14,2,28,10);
      g.lineStyle(2,0x000000,0.35); g.strokeRect(-14,-14,28,28);

      const t=pixelText("TNT",0,7,8,"#000"); t.setOrigin(0.5);
      cell.cont.add([g,t]);
      return;
    }

    const pick = drawPickaxe();
    const n = String(cell.sym.hits);
    const numShadow = pixelText(n, 15,-11,10,"#000"); numShadow.setAlpha(0.55);
    const num = pixelText(n, 14,-12,10,"#fff");

    cell.cont.add([pick,numShadow,num]);
  }

  function drawPickaxe(){
    const g=s.add.graphics();
    g.fillStyle(0x8b5a2b,1); g.fillRect(-2,-10,4,22);
    g.fillStyle(0x7a7a7a,1); g.fillRect(-12,-10,24,5);
    g.lineStyle(2,0x000000,0.30);
    g.strokeRect(-2,-10,4,22);
    g.strokeRect(-12,-10,24,5);
    return g;
  }

  // ================= TOWER =================
  function initTower(){
    towerCols=[];
    for(let c=0;c<5;c++){
      const h=START_HEIGHTS[c];
      const arr=[];
      for(let i=0;i<h;i++){
        const type = pickStartType(i);
        arr.push({type, hp:type.hp});
      }
      towerCols.push({blocks:arr});
    }
  }

  function pickStartType(level){
    if(level>=4) return Math.random()<0.70 ? BLOCKS.STONE : BLOCKS.RED;
    if(level>=2) return Math.random()<0.50 ? BLOCKS.RED : BLOCKS.GOLD;
    return Math.random()<0.55 ? BLOCKS.DIAM : BLOCKS.GOLD;
  }

  function redrawTower(){
    towerSprites.forEach(o=>o.destroy());
    towerSprites=[];

    for(let c=0;c<5;c++){
      const stack=towerCols[c].blocks;
      for(let i=0;i<stack.length;i++){
        const b=stack[i];
        const p=blockToWorld(c,i);
        const spr=drawBlockSprite(p.x,p.y,b.type);
        towerSprites.push(spr);
      }
    }
  }

  function blockToWorld(col, idx){
    const x = TOWER.x + col*TOWER.colW;
    const y = TOWER.baseY - idx*TOWER.cell;
    return {x,y};
  }

  function drawBlockSprite(x,y,t){
    const g=s.add.graphics();

    g.fillStyle(t.base,1);
    g.fillRect(x,y,24,24);

    if(t.key==="GOLD"){
      g.fillStyle(0xffffff,0.18);
      g.fillRect(x+2,y+2,8,20);
      g.fillRect(x+12,y+2,6,20);
    }

    if(t.key==="RED"){
      g.fillStyle(t.speck,1);
      g.fillRect(x+3,y+4,4,3);
      g.fillRect(x+10,y+8,5,4);
      g.fillRect(x+15,y+3,4,3);
      g.fillRect(x+6,y+15,5,4);
    } else {
      g.fillStyle(t.speck,1);
      for(let i=0;i<5;i++) g.fillRect(x+rndi(2,20), y+rndi(2,20), 2, 2);
    }

    g.lineStyle(2,0x000000,0.32);
    g.strokeRect(x,y,24,24);

    return g;
  }

  // ================= CHESTS =================
  function buildChests(){
    chests=[];
    for(let i=0;i<CHESTS_TOTAL;i++){
      const x = CHEST.startX + i*(CHEST.w + CHEST.gap);
      const obj = { x, y: CHEST.y, open:false, g:s.add.graphics(), lock:null };
      chests.push(obj);
      drawChest(i,false);
    }
  }

  function resetChests(){ chests.forEach((_,i)=>drawChest(i,false)); }

  function openChest(i){ drawChest(i,true); }

  function drawChest(i, open){
    const c=chests[i];
    c.open=open;
    c.g.clear();

    c.g.fillStyle(0xc9903a,1); c.g.fillRect(c.x,c.y,CHEST.w,CHEST.h);
    c.g.fillStyle(0xa86e2c,1); c.g.fillRect(c.x,c.y,CHEST.w,10);

    c.g.fillStyle(0x000000,0.12);
    c.g.fillRect(c.x+10,c.y,2,CHEST.h);
    c.g.fillRect(c.x+22,c.y,2,CHEST.h);
    c.g.fillRect(c.x+34,c.y,2,CHEST.h);

    c.g.lineStyle(2,0x000000,0.30);
    c.g.strokeRect(c.x,c.y,CHEST.w,CHEST.h);

    if(open){
      c.g.fillStyle(0x000000,0.10);
      c.g.fillRect(c.x,c.y-10,CHEST.w,10);

      c.g.fillStyle(0xffffff,1);
      c.g.fillRect(c.x+6,c.y-10,6,4);
      c.g.fillRect(c.x+CHEST.w-12,c.y-10,6,4);

      if(c.lock) c.lock.setVisible(false);
    } else {
      if(!c.lock){
        c.lock = s.add.text(c.x+CHEST.w/2, c.y+CHEST.h/2+2, "üîí", {fontFamily:"monospace",fontSize:"12px"}).setOrigin(0.5);
      }
      c.lock.setVisible(true);
      c.lock.setPosition(c.x+CHEST.w/2, c.y+CHEST.h/2+2);
    }
  }

  function showMul(i, mul){
    const c=chests[i];
    const pad=s.add.graphics();
    pad.fillStyle(0xffffff,0.65);
    const w=44,h=16;
    pad.fillRect(c.x+CHEST.w/2-w/2, c.y-22, w, h);
    pad.lineStyle(2,0x000000,0.20);
    pad.strokeRect(c.x+CHEST.w/2-w/2, c.y-22, w, h);

    const txt=pixelText(`x${mul}`, c.x+CHEST.w/2, c.y-14, 12, "#0b0b0b");
    txt.setOrigin(0.5);

    s.tweens.add({targets:[pad,txt], y:'-=10', duration:180, yoyo:true});
    s.tweens.add({targets:[pad,txt], alpha:0, duration:520, delay:780, onComplete:()=>{pad.destroy();txt.destroy();}});

    burst(c.x+CHEST.w/2, c.y+8, 0xffd85a);
  }

  // ================= SLAB =================
  function drawSlab(){
    const g=s.add.graphics();
    g.fillStyle(0xbdbdbd,1); g.fillRect(SLAB.x,SLAB.y,SLAB.w,SLAB.h);
    g.lineStyle(2,0x6b6b6b,1); g.strokeRect(SLAB.x,SLAB.y,SLAB.w,SLAB.h);
    g.fillStyle(0x000000,0.12); g.fillRect(SLAB.x+2, SLAB.y+SLAB.h-4, SLAB.w-4, 4);

    slabText = outlinedText("0.00", W/2, SLAB.y+SLAB.h/2+1, 16);
    fsText = pixelText("", SLAB.x-52, SLAB.y-10, 10, "rgba(0,0,0,.55)");
    fsText.setOrigin(0,1);
  }

  // ================= OVERLAY =================
  function buildOverlay(){
    overlayC = s.add.container(0,0).setDepth(500).setVisible(false);

    const dim = s.add.rectangle(W/2,H/2,W,H,0x000000,0.55);
    overlayC.add(dim);

    const t1 = outlinedText("BLOCK BONUS", W/2, H/2-46, 20);
    const t2 = outlinedText(`${FREE_SPINS} FREE SPINS`, W/2, H/2-6, 22);

    const sub = s.add.text(W/2, H/2+40, "Blocks are persistent for 4 spins.", {
      fontFamily: '"Press Start 2P", monospace',
      fontSize: "10px",
      color: "#ffffff"
    }).setOrigin(0.5);
    sub.setShadow(2,2,"rgba(0,0,0,.45)",0,true,true);

    overlayC.add([t1,t2,sub]);

    overlayC.show=()=>{ overlayC.setVisible(true); overlayC.setAlpha(0); s.tweens.add({targets:overlayC,alpha:1,duration:160}); };
    overlayC.hide=()=>{ s.tweens.add({targets:overlayC,alpha:0,duration:160,onComplete:()=>overlayC.setVisible(false)}); };
  }

  // ================= UI (BET/START + REC) =================
  function buildUI(){
    uiC = s.add.container(0,0).setDepth(600);

    const bg=s.add.graphics();
    bg.fillStyle(0x000000,0.18);
    bg.fillRect(0, H-42, W, 42);

    const minus = uiBtn(W/2-120, UI_Y, 32, 22, "-", ()=>setBet(bet-BET_STEP));
    const plus  = uiBtn(W/2+120, UI_Y, 32, 22, "+", ()=>setBet(bet+BET_STEP));

    const panel=s.add.graphics();
    panel.fillStyle(0xffffff,0.60);
    panel.fillRect(W/2-72, H-40, 144, 24);
    panel.lineStyle(2,0x000000,0.18);
    panel.strokeRect(W/2-72, H-40, 144, 24);

    const betT=s.add.text(W/2, UI_Y, `BET: ${bet}`, {
      fontFamily: '"Press Start 2P", monospace',
      fontSize: "10px",
      color: "#0b0b0b"
    }).setOrigin(0.5);

    const start = uiBtn(W/2, H-12, 180, 24, "START", ()=>startBonus());

    const hint = s.add.text(W-6, H-6, "R = REC", {
      fontFamily:'"Press Start 2P", monospace',
      fontSize:"8px",
      color:"rgba(255,255,255,.55)"
    }).setOrigin(1,1);

    uiC.add([bg, minus, plus, panel, betT, start, hint]);

    uiC.minus=minus; uiC.plus=plus; uiC.start=start; uiC.betText=betT;
  }

  function lockUI(lock){
    if(lock){
      uiC.start.disableInteractive();
      uiC.minus.disableInteractive();
      uiC.plus.disableInteractive();
    }else{
      uiC.start.setInteractive();
      uiC.minus.setInteractive();
      uiC.plus.setInteractive();
    }
  }

  function setBet(v){
    if(running) return;
    bet = clamp(v, BET_MIN, BET_MAX);
    bet = Math.round(bet/BET_STEP)*BET_STEP;
    uiC.betText.setText(`BET: ${bet}`);
  }

  // ================= REC controls =================
  function setupRECControls(){
    s.input.keyboard?.on("keydown-R", ()=>toggleREC());
    s.input.keyboard?.on("keydown-SPACE", ()=>startBonus());
    s.input.keyboard?.on("keydown-ENTER", ()=>startBonus());

    let taps=0,last=0;
    s.input.on("pointerdown",(p)=>{
      if(p.x < W-60 || p.y > 60) return;
      const now=s.time.now;
      if(now-last>450) taps=0;
      taps++; last=now;
      if(taps>=3){ taps=0; toggleREC(); }
    });
  }

  function toggleREC(){
    recMode = !recMode;
    uiC.setVisible(!recMode);
  }

  // ================= Spin animation =================
  function reelSpin(){
    return new Promise(resolve=>{
      const t0=s.time.now;
      const ev=s.time.addEvent({
        delay:55, loop:true,
        callback:()=>{
          randomizePanel(false);
          if(s.time.now-t0>=REEL_SPIN_MS){
            ev.remove(false);
            randomizePanel(true);
            resolve();
          }
        }
      });
    });
  }

  // ================= FX =================
  function floatWin(x,y,add){
    const txt = outlinedText(fmt(add), x, y, 12);
    txt.setDepth(400);
    s.tweens.add({targets:txt, y:y-18, alpha:0, duration:700, onComplete:()=>txt.destroy()});
  }

  function burst(x,y,color){
    for(let i=0;i<10;i++){
      const p=s.add.rectangle(x,y,2,2,color,1).setDepth(300);
      s.tweens.add({
        targets:p,
        x:x+rnd(-24,24),
        y:y+rnd(-24,24),
        alpha:{from:1,to:0},
        duration:260,
        onComplete:()=>p.destroy()
      });
    }
  }

  // ================= Text helpers =================
  function pixelText(str,x,y,size,color){
    return s.add.text(x,y,String(str),{
      fontFamily: '"Press Start 2P", monospace',
      fontSize: `${size}px`,
      color: color
    });
  }

  function outlinedText(str,x,y,size){
    const c=s.add.container(x,y);
    const t=String(str);

    const shadow = s.add.text(2,2,t,{fontFamily:'"Press Start 2P", monospace',fontSize:`${size}px`,color:"#000"}).setOrigin(0.5);
    shadow.setAlpha(0.8);

    const main = s.add.text(0,0,t,{fontFamily:'"Press Start 2P", monospace',fontSize:`${size}px`,color:"#fff"}).setOrigin(0.5);
    main.setShadow(2,2,"rgba(0,0,0,.55)",0,true,true);

    c.add([shadow,main]);
    c.setText=(v)=>{ const nv=String(v); shadow.setText(nv); main.setText(nv); };
    return c;
  }

  // ================= Utils =================
  function setTotal(v){ total=Math.max(0,v); }
  function wait(ms){ return new Promise(r=>s.time.delayedCall(ms,r)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function rndi(a,b){ return Math.floor(rnd(a,b)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function fmt(v){ return Math.max(0,v).toFixed(DECIMALS); }
  function makeNice(v){
    let x=Math.max(0,v);
    const step = x<10?0.1:x<100?0.5:x<1000?1:x<10000?5:10;
    x=Math.ceil(x/step)*step;
    return Number(x.toFixed(DECIMALS));
  }
  function pickW(values, weights){
    const sum=weights.reduce((a,b)=>a+b,0);
    let r=Math.random()*sum;
    for(let i=0;i<values.length;i++){ r-=weights[i]; if(r<=0) return values[i]; }
    return values[values.length-1];
  }

  // ================= UI Button =================
  function uiBtn(x,y,w,h,label,onClick){
    const c=s.add.container(x,y);
    const g=s.add.graphics();

    const draw=(pressed=false)=>{
      g.clear();
      g.fillStyle(0xb7b7b7,1); g.fillRect(-w/2,-h/2,w,h);
      g.fillStyle(0x8f8f8f,1); g.fillRect(-w/2,-h/2,w,6);
      g.fillStyle(0xd7d7d7,1); g.fillRect(-w/2,h/2-6,w,6);
      g.lineStyle(2,0x3a3a3a,1); g.strokeRect(-w/2,-h/2,w,h);
      if(pressed){ g.fillStyle(0x000000,0.10); g.fillRect(-w/2,-h/2,w,h); }
    };
    draw(false);

    const t=s.add.text(0,0,label,{fontFamily:'"Press Start 2P", monospace',fontSize:"10px",color:"#101010"}).setOrigin(0.5);

    c.add([g,t]);
    c.setSize(w,h);
    c.setInteractive(new Phaser.Geom.Rectangle(-w/2,-h/2,w,h), Phaser.Geom.Rectangle.Contains);
    c.on("pointerdown", ()=>{ draw(true); s.time.delayedCall(90,()=>draw(false)); onClick(); });
    return c;
  }

})();
</script>
</body>
</html>

