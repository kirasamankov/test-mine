<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Block Bonus ‚Äì Demo</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    html,body{height:100%;margin:0;background:#79d0ff;overflow:hidden}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:10px}
    canvas{
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius: 18px;
      box-shadow: 0 30px 90px rgba(0,0,0,.35);
      outline: 2px solid rgba(0,0,0,.25);
      background:#79d0ff;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>
<body>
<div id="wrap"></div>

<script>
(() => {
  // === –í–ê–ñ–ù–û: —á–µ—Å—Ç–Ω–∞—è –ø–æ–º–µ—Ç–∫–∞, —á—Ç–æ–±—ã –Ω–µ –≤–≤–æ–¥–∏—Ç—å –ª—é–¥–µ–π –≤ –∑–∞–±–ª—É–∂–¥–µ–Ω–∏–µ ===
  const DEMO_WATERMARK = "DEMO / SIMULATION";

  // === –ë–û–ù–£–° / –§–ò–ó–ò–ö–ê –∫–∞–∫ –≤ –≤–∏–¥–µ–æ ===
  const FREE_SPINS = 4; // 4 –±–µ—Å–ø–ª–∞—Ç–Ω—ã—Ö –≤—Ä–∞—â–µ–Ω–∏—è
  const PANEL = { cols:5, rows:3 };
  const DECIMALS = 2;

  // –ë–µ—Ç (–±–µ–∑ –≤–∞–ª—é—Ç—ã)
  const BET_MIN = 10, BET_MAX = 5000, BET_STEP = 10;

  // –°—É–Ω–¥—É–∫–∏
  const CHESTS_TOTAL = 5;
  const OPEN_MIN = 3, OPEN_MAX = 5; // 3..5

  // –¢–∞–π–º–∏–Ω–≥–∏/–∞–Ω–∏–º–∞—Ü–∏–∏ (–ø–æ—Ö–æ–∂–µ –Ω–∞ –≤–∏–¥–µ–æ)
  const REEL_SPIN_MS = 650;
  const OVERLAY_MS = 900;
  const BETWEEN_SPINS_MS = 220;
  const HIT_STEP_MS = 95;
  const CHEST_STEP_MS = 420;

  // === CANVAS (9:16) ===
  const W = 360, H = 640;

  // –†–∞–∑–º–µ—Ç–∫–∞ (–∫–∞–∫ –≤ —Ç–≤–æ—ë–º –≤–∏–¥–µ–æ)
  const TOP = { x: 64, y: 26, w: 232, h: 128 };
  const TOWER = { x: 120, baseY: 476, colW: 24, cell: 24, cols:5 };
  const CHEST = { y: 500, w: 44, h: 44, gap: 6, startX: 60 };
  const SLAB  = { x: 86, y: 560, w: 188, h: 32 };

  // –°—Ç–∞—Ä—Ç–æ–≤–∞—è ‚Äú—Ñ–æ—Ä–º–∞‚Äù –±–ª–æ–∫–æ–≤ (—Å—Ç—É–ø–µ–Ω—å–∫–∞–º–∏)
  const START_HEIGHTS = [6,5,6,5,6];

  // === –ö–ò–†–ö–ò (–∫–∞–∫ –≤ –≤–∏–¥–µ–æ: —Ä–∞–∑–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã + —á–∏—Å–ª–æ —É–¥–∞—Ä–æ–≤) ===
  // hits = —Å–∫–æ–ª—å–∫–æ —É–¥–∞—Ä–æ–≤ –¥–æ–±–∞–≤–ª—è–µ—Ç —ç—Ç–∞ –∫–∏—Ä–∫–∞ –≤ –∫–æ–ª–æ–Ω–∫—É
  const PICKAXES = [
    { key:"WOOD",    hits:1, color:0x8b5a2b, metal:0x9a9a9a },
    { key:"STONE",   hits:2, color:0x6b4a2b, metal:0x7f8c8d },
    { key:"GOLD",    hits:3, color:0x7a4d20, metal:0xf1c40f },
    { key:"DIAMOND", hits:4, color:0x5b3a1e, metal:0x4be7ff }
  ];

  // === –ö–ù–ò–ñ–ö–ê: –∞–ø–≥—Ä–µ–π–¥ –∫–∏—Ä–æ–∫ –≤ –∞–ª–º–∞–∑–Ω—ã–µ (–∫–∞–∫ —Ç—ã –æ–ø–∏—Å–∞–ª) ===
  const BOOK_CHANCE = 0.08; // —à–∞–Ω—Å –∫–Ω–∏–∂–∫–∏ –≤ —è—á–µ–π–∫–µ (–º–æ–∂–Ω–æ –ø–æ–¥–ø—Ä–∞–≤–∏—Ç—å)

  // –ü—É—Å—Ç—ã–µ –∫–ª–µ—Ç–∫–∏ –≤ –ø–∞–Ω–µ–ª–∏ (–≤ —Ç–≤–æ—ë–º –≤–∏–¥–µ–æ —á–∞—Å—Ç–æ –µ—Å—Ç—å –ø—É—Å—Ç—ã–µ)
  const EMPTY_CHANCE = 0.35;

  // === –ë–õ–û–ö–ò (–≤–∏–∑—É–∞–ª—å–Ω–æ –∫–∞–∫ –≤ –≤–∏–¥–µ–æ: stone/red/diamond/gold/obsidian) ===
  const BLOCKS = {
    STONE: { key:"STONE", hp:1, pay:0.15, base:0xd8d8d8, speck:0xa7a7a7 },
    RED:   { key:"RED",   hp:1, pay:0.30, base:0xdedede, speck:0xc93a3a },
    DIAM:  { key:"DIAM",  hp:1, pay:0.70, base:0x57e9ff, speck:0x2fb9d2 },
    GOLD:  { key:"GOLD",  hp:1, pay:0.55, base:0xffd85a, speck:0xeab021 },
    OBSI:  { key:"OBSI",  hp:2, pay:1.50, base:0x1c1630, speck:0x2f2850 },
  };

  // Phaser (CANVAS ‚Äî —á—Ç–æ–±—ã –Ω–µ –±—ã–ª–æ —á—ë—Ä–Ω–æ–≥–æ —ç–∫—Ä–∞–Ω–∞)
  new Phaser.Game({
    type: Phaser.CANVAS,
    parent: "wrap",
    width: W,
    height: H,
    backgroundColor: "#79d0ff",
    pixelArt: true,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: { create, update }
  });

  let s;
  let running=false, recMode=false;

  // –¥–µ–Ω—å–≥–∏/—Å—Ç–∞–≤–∫–∞
  let bet=100;
  let total=0, totalDisp=0;

  // UI
  let slabText, fsText, overlayC, uiC;

  // –≤–µ—Ä—Ö–Ω—è—è –ø–∞–Ω–µ–ª—å (5x3)
  let topG;
  let topCells=[]; // {r,c,cont,item}

  // –±–∞—à–Ω—è –±–ª–æ–∫–æ–≤: 5 –∫–æ–ª–æ–Ω–æ–∫, –∫–∞–∂–¥–∞—è ‚Äî –º–∞—Å—Å–∏–≤ –±–ª–æ–∫–æ–≤ —Å–Ω–∏–∑—É –≤–≤–µ—Ä—Ö
  let cols=[]; // [{blocks:[{type,hp}]}]
  let blockSprites=[];

  // —Å—É–Ω–¥—É–∫–∏
  let chests=[];

  // –≤–æ–¥—è–Ω–æ–π –∑–Ω–∞–∫
  let watermark;

  function create(){
    s=this;

    drawSky();
    drawGround();

    drawTopFrame();
    buildTopCells();

    initTower();
    redrawTower();

    buildChests();
    drawSlab();

    buildOverlay();
    buildUI();
    setupREC();

    watermark = s.add.text(8, 8, DEMO_WATERMARK, {
      fontFamily: '"Press Start 2P", monospace',
      fontSize: '8px',
      color: 'rgba(0,0,0,.35)'
    }).setDepth(999);

    setTotal(0);
    renderTopPanel(makeSpinPanel(true)); // –Ω–∞—á–∞–ª—å–Ω–æ–µ —Å–æ—Å—Ç–æ—è–Ω–∏–µ
  }

  function update(){
    totalDisp += (total-totalDisp)*0.18;
    if(Math.abs(total-totalDisp)<0.005) totalDisp=total;
    slabText.setText(fmt(totalDisp));
  }

  // ============================
  // FLOW 1: BLOCK BONUS ‚Üí 4 SPINS ‚Üí CHESTS
  // ============================
  async function startBonus(){
    if(running) return;
    running=true;
    lockUI(true);

    setTotal(0);
    resetChests();

    initTower();
    redrawTower();

    overlayC.show();
    await wait(OVERLAY_MS);
    overlayC.hide();
    await wait(220);

    for(let i=0;i<FREE_SPINS;i++){
      fsText.setText(`FREE SPIN ${i+1}/${FREE_SPINS}`);
      await oneSpin();
      await wait(BETWEEN_SPINS_MS);
    }
    fsText.setText("");

    await chestPhase();

    running=false;
    lockUI(false);
  }

  async function oneSpin(){
    // ‚Äú–∫—Ä—É—Ç–∏–ª–∫–∞‚Äù –∫–∞–∫ –≤ –≤–∏–¥–µ–æ: –±—ã—Å—Ç—Ä–æ –º–µ–Ω—è–µ–º –ø–∞–Ω–µ–ª—å
    await reelSpin();

    // –ü–æ–ª—É—á–∞–µ–º —Ñ–∏–Ω–∞–ª—å–Ω—É—é –ø–∞–Ω–µ–ª—å —Å–ø–∏–Ω–∞
    const panel = makeSpinPanel(false);
    renderTopPanel(panel);

    // –ï—Å–ª–∏ –µ—Å—Ç—å –∫–Ω–∏–∂–∫–∞ ‚Äî –∞–ø–≥—Ä–µ–π–¥ ‚Äú–≤—Å–µ –∫–∏—Ä–∫–∏ –≤ –∞–ª–º–∞–∑–Ω—ã–µ‚Äù (–∫–∞–∫ —Ç—ã —Å–∫–∞–∑–∞–ª)
    const hasBook = panel.some(x => x && x.kind==="BOOK");
    if(hasBook){
      await bookUpgradeFlash();
      for(let i=0;i<panel.length;i++){
        if(panel[i] && panel[i].kind==="PICK"){
          panel[i].pick = PICKAXES[3]; // DIAMOND
        }
      }
      renderTopPanel(panel);
    }

    // –°—á–∏—Ç–∞–µ–º ‚Äú—É–¥–∞—Ä—ã‚Äù –ø–æ –∫–æ–ª–æ–Ω–∫–∞–º (–∫–∞–∫ –≤ –≤–∏–¥–µ–æ: –∫–∏—Ä–∫–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç hits –≤ —Å–≤–æ—é –∫–æ–ª–æ–Ω–∫—É)
    const hits = new Array(PANEL.cols).fill(0);
    panel.forEach((cell, idx) => {
      if(!cell) return;
      const c = idx % PANEL.cols;
      if(cell.kind==="PICK") hits[c] += cell.pick.hits;
    });

    // –ü—Ä–∏–º–µ–Ω—è–µ–º —É–¥–∞—Ä—ã: –ª–æ–º–∞–µ–º –≤–µ—Ä—Ö–Ω–∏–µ –±–ª–æ–∫–∏, –±–ª–æ–∫–∏ ‚Äú–ø–∞–¥–∞—é—Ç‚Äù (stack.pop())
    for(let c=0;c<PANEL.cols;c++){
      let left = hits[c];
      while(left>0){
        const ok = hitTopBlock(c);
        if(!ok) break;
        left--;
        await wait(HIT_STEP_MS);
      }
      redrawTower(); // –ø–æ—Å–ª–µ —É–¥–∞—Ä–æ–≤ –∫–æ–ª–æ–Ω–∫–∞ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∞–Ω–∞, –≤—ã–≥–ª—è–¥–∏—Ç –∫–∞–∫ –ø–∞–¥–µ–Ω–∏–µ
    }
  }

  function hitTopBlock(col){
    const stack = cols[col].blocks;
    if(stack.length===0) return false;

    const b = stack[stack.length-1];
    b.hp -= 1;

    const p = blockToWorld(col, stack.length-1);
    burst(p.x+12, p.y+12, b.type.speck);

    if(b.hp<=0){
      stack.pop();
      const add = bet * b.type.pay;
      setTotal(total + add);
      floatWin(p.x+12, p.y-6, add);
    }
    return true;
  }

  async function chestPhase(){
    const openCount = rndi(OPEN_MIN, OPEN_MAX+1);

    // –º–µ–Ω—å—à–µ —Å—É–Ω–¥—É–∫–æ–≤ ‚Üí –≤—ã—à–µ –º—É–ª—å—Ç—ã
    const pool = (openCount===3)
      ? {v:[5,10,12,15,20,25,30,40,50], w:[6,14,14,14,14,12,10,8,8]}
      : (openCount===4)
      ? {v:[2,3,5,8,10,12,15,20,25], w:[18,16,16,14,12,10,8,4,2]}
      : {v:[2,2,3,3,5,5,8,10,12], w:[22,20,16,14,12,8,5,2,1]};

    // –∫–∞–∫ –≤ —Ç–≤–æ—ë–º –∫–∞–¥—Ä–µ ‚Äî —Ü–µ–Ω—Ç—Ä —á–∞—Å—Ç–æ –æ—Å—Ç–∞–≤–ª—è—é—Ç –∑–∞–∫—Ä—ã—Ç—ã–º
    const order=[0,1,3,4,2];
    let opened=0;
    let cur=total;

    for(const idx of order){
      if(opened>=openCount) break;
      if(idx===2 && openCount<5 && Math.random()<0.75) continue;

      const mul = pickW(pool.v, pool.w);
      openChest(idx);
      showMul(idx, mul);

      cur = cur * mul;
      setTotal(cur);

      opened++;
      await wait(CHEST_STEP_MS);
    }

    // –¥–æ–±–∏–≤–∞–µ–º, –µ—Å–ª–∏ –∏–∑-–∑–∞ –ø—Ä–æ–ø—É—Å–∫–∞ —Ü–µ–Ω—Ç—Ä–∞ –Ω–µ —Ö–≤–∞—Ç–∏–ª–æ
    if(opened<openCount){
      for(const idx of [0,4,1,3,2]){
        if(opened>=openCount) break;
        if(chests[idx].open) continue;

        const mul = pickW(pool.v, pool.w);
        openChest(idx);
        showMul(idx, mul);

        cur = cur * mul;
        setTotal(cur);

        opened++;
        await wait(CHEST_STEP_MS);
      }
    }

    setTotal(makeNice(cur));
    await wait(260);
  }

  // ============================
  // TOP PANEL (5x3)
  // ============================
  function drawTopFrame(){
    const {x,y,w,h} = TOP;
    topG = s.add.graphics();

    topG.fillStyle(0xd0d0d0,1); topG.fillRect(x,y,w,h);
    topG.lineStyle(3,0x6b6b6b,1); topG.strokeRect(x,y,w,h);
    topG.lineStyle(2,0x8d8d8d,1); topG.strokeRect(x+2,y+2,w-4,h-4);

    const cw=Math.floor(w/PANEL.cols);
    const ch=Math.floor(h/PANEL.rows);

    topG.lineStyle(2,0xffffff,0.9);
    for(let c=1;c<PANEL.cols;c++){
      topG.beginPath(); topG.moveTo(x+c*cw,y+6); topG.lineTo(x+c*cw,y+h-6); topG.strokePath();
    }
    for(let r=1;r<PANEL.rows;r++){
      topG.beginPath(); topG.moveTo(x+6,y+r*ch); topG.lineTo(x+w-6,y+r*ch); topG.strokePath();
    }
  }

  function buildTopCells(){
    topCells=[];
    const {x,y,w,h} = TOP;
    const cw=Math.floor(w/PANEL.cols);
    const ch=Math.floor(h/PANEL.rows);

    for(let r=0;r<PANEL.rows;r++){
      for(let c=0;c<PANEL.cols;c++){
        const cont = s.add.container(x+c*cw+cw/2, y+r*ch+ch/2);
        topCells.push({r,c,cont,item:null});
      }
    }
  }

  function makeSpinPanel(forceSome){
    // –º–∞—Å—Å–∏–≤ –¥–ª–∏–Ω–æ–π 15 (row-major)
    const out = [];
    for(let i=0;i<PANEL.cols*PANEL.rows;i++){
      // –ø—É—Å—Ç—ã–µ
      if(Math.random() < EMPTY_CHANCE){
        out.push(null);
        continue;
      }
      // –∫–Ω–∏–∂–∫–∞
      if(Math.random() < BOOK_CHANCE){
        out.push({kind:"BOOK"});
        continue;
      }
      // –∫–∏—Ä–∫–∞ (—Ä–∞–∑–Ω—ã–µ –º–∞—Ç–µ—Ä–∏–∞–ª—ã)
      // —Ä–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –ø–æ—Ö–æ–∂–µ –Ω–∞ –≤–∏–¥–µ–æ: –¥–µ—Ä–µ–≤–æ —á–∞—â–µ, –∞–ª–º–∞–∑ —Ä–µ–∂–µ
      const pick = pickW(
        [PICKAXES[0], PICKAXES[1], PICKAXES[2], PICKAXES[3]],
        [46, 30, 18, 6]
      );
      out.push({kind:"PICK", pick});
    }

    // —á—Ç–æ–±—ã –≤ –ø–µ—Ä–≤–æ–º –∫–∞–¥—Ä–µ –Ω–µ –±—ã–ª–æ —Å–æ–≤—Å–µ–º –ø—É—Å—Ç–æ
    if(forceSome){
      out[1] = {kind:"PICK", pick:PICKAXES[0]};
      out[2] = {kind:"PICK", pick:PICKAXES[0]};
      out[3] = {kind:"PICK", pick:PICKAXES[2]};
      out[6] = {kind:"PICK", pick:PICKAXES[1]};
    }
    return out;
  }

  function renderTopPanel(panel){
    for(let i=0;i<topCells.length;i++){
      const cell = topCells[i];
      cell.item = panel[i];
      cell.cont.removeAll(true);

      if(!panel[i]) continue;

      if(panel[i].kind==="BOOK"){
        cell.cont.add(drawBookIcon());
      }else{
        cell.cont.add(drawPickaxeIcon(panel[i].pick.hits, panel[i].pick.metal));
      }
    }
  }

  function drawPickaxeIcon(hits, metalColor){
    const g = s.add.graphics();

    // —Ä—É—á–∫–∞
    g.fillStyle(0x8b5a2b,1);
    g.fillRect(-2,-10,4,22);

    // ‚Äú–º–µ—Ç–∞–ª–ª‚Äù –∫–∏—Ä–∫–∏ (—Ü–≤–µ—Ç –∑–∞–≤–∏—Å–∏—Ç –æ—Ç –º–∞—Ç–µ—Ä–∏–∞–ª–∞)
    g.fillStyle(metalColor,1);
    g.fillRect(-12,-10,24,5);

    // –∫–æ–Ω—Ç—É—Ä
    g.lineStyle(2,0x000000,0.30);
    g.strokeRect(-2,-10,4,22);
    g.strokeRect(-12,-10,24,5);

    // —Ü–∏—Ñ—Ä–∞ —É–¥–∞—Ä–æ–≤
    const n = String(hits);
    const sh = pixelText(n, 15,-11,10,"#000"); sh.setAlpha(0.55);
    const tx = pixelText(n, 14,-12,10,"#fff");

    const c = s.add.container(0,0);
    c.add([g, sh, tx]);
    return c;
  }

  function drawBookIcon(){
    const c = s.add.container(0,0);
    const g = s.add.graphics();

    g.fillStyle(0x2ecc71,1); g.fillRect(-12,-12,24,24);
    g.fillStyle(0xffffff,1); g.fillRect(-10,-10,10,20);
    g.fillStyle(0x0b8f3a,1); g.fillRect(0,-10,10,20);

    g.lineStyle(2,0x000000,0.30);
    g.strokeRect(-12,-12,24,24);

    const t = pixelText("B", 0, 4, 10, "#000"); t.setOrigin(0.5);
    c.add([g,t]);
    return c;
  }

  async function bookUpgradeFlash(){
    // –∫–æ—Ä–æ—Ç–∫–∞—è ‚Äú–≤—Å–ø—ã—à–∫–∞‚Äù –∫–∞–∫ –∞–ø–≥—Ä–µ–π–¥
    const r = s.add.rectangle(W/2, TOP.y + TOP.h/2, TOP.w, TOP.h, 0x4be7ff, 0.25).setDepth(400);
    await wait(90);
    r.destroy();
    await wait(60);
  }

  function reelSpin(){
    return new Promise(resolve=>{
      const t0=s.time.now;
      const ev=s.time.addEvent({
        delay:55, loop:true,
        callback:()=>{
          renderTopPanel(makeSpinPanel(false));
          if(s.time.now-t0>=REEL_SPIN_MS){
            ev.remove(false);
            resolve();
          }
        }
      });
    });
  }

  // ============================
  // TOWER (blocks + falling)
  // ============================
  function initTower(){
    cols=[];
    for(let c=0;c<TOWER.cols;c++){
      const h = START_HEIGHTS[c];
      const arr=[];
      for(let i=0;i<h;i++){
        const type = pickStartBlock(i);
        arr.push({type, hp:type.hp});
      }
      cols.push({blocks:arr});
    }
  }

  function pickStartBlock(level){
    // –≤–µ—Ä—Ö ‚Äî –±–æ–ª—å—à–µ stone/red, –Ω–∏–∑ ‚Äî –±–æ–ª—å—à–µ gold/diamond
    if(level>=4) return Math.random()<0.70 ? BLOCKS.STONE : BLOCKS.RED;
    if(level>=2) return Math.random()<0.55 ? BLOCKS.RED : BLOCKS.GOLD;
    return Math.random()<0.55 ? BLOCKS.DIAM : BLOCKS.GOLD;
  }

  function redrawTower(){
    blockSprites.forEach(o=>o.destroy());
    blockSprites=[];

    for(let c=0;c<TOWER.cols;c++){
      const stack = cols[c].blocks;
      for(let i=0;i<stack.length;i++){
        const b=stack[i];
        const p=blockToWorld(c,i);
        blockSprites.push(drawBlock(p.x,p.y,b.type));
      }
    }
  }

  function blockToWorld(col, idx){
    const x = TOWER.x + col*TOWER.colW;
    const y = TOWER.baseY - idx*TOWER.cell;
    return {x,y};
  }

  function drawBlock(x,y,t){
    const g=s.add.graphics();
    g.fillStyle(t.base,1);
    g.fillRect(x,y,24,24);

    if(t.key==="GOLD"){
      g.fillStyle(0xffffff,0.18);
      g.fillRect(x+2,y+2,8,20);
      g.fillRect(x+12,y+2,6,20);
    }

    if(t.key==="RED"){
      g.fillStyle(t.speck,1);
      g.fillRect(x+3,y+4,4,3);
      g.fillRect(x+10,y+8,5,4);
      g.fillRect(x+15,y+3,4,3);
      g.fillRect(x+6,y+15,5,4);
    } else {
      g.fillStyle(t.speck,1);
      for(let i=0;i<5;i++) g.fillRect(x+rndi(2,20), y+rndi(2,20), 2, 2);
    }

    g.lineStyle(2,0x000000,0.32);
    g.strokeRect(x,y,24,24);
    return g;
  }

  // ============================
  // CHESTS
  // ============================
  function buildChests(){
    chests=[];
    for(let i=0;i<CHESTS_TOTAL;i++){
      const x = CHEST.startX + i*(CHEST.w+CHEST.gap);
      const obj = {x, y:CHEST.y, open:false, g:s.add.graphics(), lock:null};
      chests.push(obj);
      drawChest(i,false);
    }
  }

  function resetChests(){ chests.forEach((_,i)=>drawChest(i,false)); }
  function openChest(i){ drawChest(i,true); }

  function drawChest(i, open){
    const c=chests[i];
    c.open=open;
    c.g.clear();

    c.g.fillStyle(0xc9903a,1); c.g.fillRect(c.x,c.y,CHEST.w,CHEST.h);
    c.g.fillStyle(0xa86e2c,1); c.g.fillRect(c.x,c.y,CHEST.w,10);

    c.g.fillStyle(0x000000,0.12);
    c.g.fillRect(c.x+10,c.y,2,CHEST.h);
    c.g.fillRect(c.x+22,c.y,2,CHEST.h);
    c.g.fillRect(c.x+34,c.y,2,CHEST.h);

    c.g.lineStyle(2,0x000000,0.30);
    c.g.strokeRect(c.x,c.y,CHEST.w,CHEST.h);

    if(open){
      c.g.fillStyle(0x000000,0.10);
      c.g.fillRect(c.x,c.y-10,CHEST.w,10);

      c.g.fillStyle(0xffffff,1);
      c.g.fillRect(c.x+6,c.y-10,6,4);
      c.g.fillRect(c.x+CHEST.w-12,c.y-10,6,4);

      if(c.lock) c.lock.setVisible(false);
    } else {
      if(!c.lock){
        c.lock = s.add.text(c.x+CHEST.w/2, c.y+CHEST.h/2+2, "üîí", {
          fontFamily:"monospace", fontSize:"12px"
        }).setOrigin(0.5);
      }
      c.lock.setVisible(true);
      c.lock.setPosition(c.x+CHEST.w/2, c.y+CHEST.h/2+2);
    }
  }

  function showMul(i, mul){
    const c=chests[i];

    const pad=s.add.graphics();
    pad.fillStyle(0xffffff,0.65);
    const w=44,h=16;
    pad.fillRect(c.x+CHEST.w/2-w/2, c.y-22, w, h);
    pad.lineStyle(2,0x000000,0.20);
    pad.strokeRect(c.x+CHEST.w/2-w/2, c.y-22, w, h);

    const txt=pixelText(`x${mul}`, c.x+CHEST.w/2, c.y-14, 12, "#0b0b0b");
    txt.setOrigin(0.5);

    s.tweens.add({targets:[pad,txt], y:'-=10', duration:180, yoyo:true});
    s.tweens.add({
      targets:[pad,txt],
      alpha:0,
      duration:520,
      delay:780,
      onComplete:()=>{pad.destroy();txt.destroy();}
    });

    burst(c.x+CHEST.w/2, c.y+8, 0xffd85a);
  }

  // ============================
  // SLAB (–∏—Ç–æ–≥)
  // ============================
  function drawSlab(){
    const g=s.add.graphics();
    g.fillStyle(0xbdbdbd,1); g.fillRect(SLAB.x,SLAB.y,SLAB.w,SLAB.h);
    g.lineStyle(2,0x6b6b6b,1); g.strokeRect(SLAB.x,SLAB.y,SLAB.w,SLAB.h);
    g.fillStyle(0x000000,0.12); g.fillRect(SLAB.x+2, SLAB.y+SLAB.h-4, SLAB.w-4, 4);

    slabText = outlinedText("0.00", W/2, SLAB.y+SLAB.h/2+1, 16);
    fsText = pixelText("", SLAB.x-52, SLAB.y-10, 10, "rgba(0,0,0,.55)");
    fsText.setOrigin(0,1);
  }

  // ============================
  // OVERLAY
  // ============================
  function buildOverlay(){
    overlayC = s.add.container(0,0).setDepth(500).setVisible(false);

    const dim = s.add.rectangle(W/2,H/2,W,H,0x000000,0.55);
    overlayC.add(dim);

    const t1 = outlinedText("BLOCK BONUS", W/2, H/2-46, 20);
    const t2 = outlinedText(`${FREE_SPINS} FREE SPINS`, W/2, H/2-6, 22);

    const sub = s.add.text(W/2, H/2+40, "Blocks are persistent for 4 spins.", {
      fontFamily: '"Press Start 2P", monospace',
      fontSize: "10px",
      color: "#ffffff"
    }).setOrigin(0.5);
    sub.setShadow(2,2,"rgba(0,0,0,.45)",0,true,true);

    overlayC.add([t1,t2,sub]);

    overlayC.show=()=>{ overlayC.setVisible(true); overlayC.setAlpha(0); s.tweens.add({targets:overlayC,alpha:1,duration:160}); };
    overlayC.hide=()=>{ s.tweens.add({targets:overlayC,alpha:0,duration:160,onComplete:()=>overlayC.setVisible(false)}); };
  }

  // ============================
  // UI (BET / START) + REC
  // ============================
  function buildUI(){
    uiC = s.add.container(0,0).setDepth(600);

    const bg=s.add.graphics();
    bg.fillStyle(0x000000,0.18);
    bg.fillRect(0, H-42, W, 42);

    const minus = uiBtn(W/2-120, H-22, 32, 22, "-", ()=>setBet(bet-BET_STEP));
    const plus  = uiBtn(W/2+120, H-22, 32, 22, "+", ()=>setBet(bet+BET_STEP));

    const panel=s.add.graphics();
    panel.fillStyle(0xffffff,0.60);
    panel.fillRect(W/2-72, H-34, 144, 24);
    panel.lineStyle(2,0x000000,0.18);
    panel.strokeRect(W/2-72, H-34, 144, 24);

    const betT=s.add.text(W/2, H-22, `BET: ${bet}`, {
      fontFamily: '"Press Start 2P", monospace',
      fontSize: "10px",
      color: "#0b0b0b"
    }).setOrigin(0.5);

    const start = uiBtn(W/2, H-10, 180, 24, "START", ()=>startBonus());

    const hint = s.add.text(W-6, H-6, "R = REC", {
      fontFamily:'"Press Start 2P", monospace',
      fontSize:"8px",
      color:"rgba(255,255,255,.55)"
    }).setOrigin(1,1);

    uiC.add([bg, minus, plus, panel, betT, start, hint]);
    uiC.minus=minus; uiC.plus=plus; uiC.start=start; uiC.betText=betT;
  }

  function lockUI(lock){
    if(lock){
      uiC.start.disableInteractive();
      uiC.minus.disableInteractive();
      uiC.plus.disableInteractive();
    }else{
      uiC.start.setInteractive();
      uiC.minus.setInteractive();
      uiC.plus.setInteractive();
    }
  }

  function setBet(v){
    if(running) return;
    bet = clamp(v, BET_MIN, BET_MAX);
    bet = Math.round(bet/BET_STEP)*BET_STEP;
    uiC.betText.setText(`BET: ${bet}`);
  }

  function setupREC(){
    s.input.keyboard?.on("keydown-R", ()=>toggleREC());
    s.input.keyboard?.on("keydown-SPACE", ()=>startBonus());
    s.input.keyboard?.on("keydown-ENTER", ()=>startBonus());

    // —Ç—Ä–æ–π–Ω–æ–π —Ç–∞–ø (—Ç–µ–ª–µ—Ñ–æ–Ω)
    let taps=0,last=0;
    s.input.on("pointerdown",(p)=>{
      if(p.x < W-60 || p.y > 60) return;
      const now=s.time.now;
      if(now-last>450) taps=0;
      taps++; last=now;
      if(taps>=3){ taps=0; toggleREC(); }
    });
  }

  function toggleREC(){
    recMode=!recMode;
    uiC.setVisible(!recMode);
    // watermark –æ—Å—Ç–∞–≤–ª—è–µ–º (—á–µ—Å—Ç–Ω–∞—è –ø–æ–º–µ—Ç–∫–∞)
  }

  // ============================
  // BACKGROUND
  // ============================
  function drawSky(){
    s.add.rectangle(W/2,H/2,W,H,0x79d0ff).setDepth(-50);
    for(let i=0;i<8;i++) cloud(rndi(10,W-70), rndi(20,200), rndi(22,40));
  }

  function cloud(x,y,size){
    const g=s.add.graphics().setDepth(-40);
    g.fillStyle(0xffffff,1);
    g.fillRect(x,y,size,size/2);
    g.fillRect(x+10,y-6,size,size/2);
    g.fillRect(x+22,y+2,size,size/2);
    g.fillStyle(0x000000,0.06);
    g.fillRect(x,y+size/2-2,size+22,3);
  }

  function drawGround(){
    const g=s.add.graphics().setDepth(-30);
    g.fillStyle(0x5fd23f,1); g.fillRect(0,520,W,14);
    g.fillStyle(0xb8743c,1); g.fillRect(0,534,W,106);
    g.fillStyle(0x000000,0.08); g.fillRect(0,520,W,120);
  }

  // ============================
  // FX / TEXT
  // ============================
  function floatWin(x,y,add){
    const txt = outlinedText(fmt(add), x, y, 12);
    txt.setDepth(400);
    s.tweens.add({targets:txt, y:y-18, alpha:0, duration:700, onComplete:()=>txt.destroy()});
  }

  function burst(x,y,color){
    for(let i=0;i<10;i++){
      const p=s.add.rectangle(x,y,2,2,color,1).setDepth(300);
      s.tweens.add({
        targets:p,
        x:x+rnd(-24,24),
        y:y+rnd(-24,24),
        alpha:{from:1,to:0},
        duration:260,
        onComplete:()=>p.destroy()
      });
    }
  }

  function pixelText(str,x,y,size,color){
    return s.add.text(x,y,String(str),{
      fontFamily: '"Press Start 2P", monospace',
      fontSize: `${size}px`,
      color: color
    });
  }

  function outlinedText(str,x,y,size){
    const c=s.add.container(x,y);
    const t=String(str);

    const shadow = s.add.text(2,2,t,{
      fontFamily:'"Press Start 2P", monospace',
      fontSize:`${size}px`,
      color:"#000"
    }).setOrigin(0.5);
    shadow.setAlpha(0.8);

    const main = s.add.text(0,0,t,{
      fontFamily:'"Press Start 2P", monospace',
      fontSize:`${size}px`,
      color:"#fff"
    }).setOrigin(0.5);
    main.setShadow(2,2,"rgba(0,0,0,.55)",0,true,true);

    c.add([shadow,main]);
    c.setText=(v)=>{ const nv=String(v); shadow.setText(nv); main.setText(nv); };
    return c;
  }

  function uiBtn(x,y,w,h,label,onClick){
    const c=s.add.container(x,y);
    const g=s.add.graphics();

    const draw=(pressed=false)=>{
      g.clear();
      g.fillStyle(0xb7b7b7,1); g.fillRect(-w/2,-h/2,w,h);
      g.fillStyle(0x8f8f8f,1); g.fillRect(-w/2,-h/2,w,6);
      g.fillStyle(0xd7d7d7,1); g.fillRect(-w/2,h/2-6,w,6);
      g.lineStyle(2,0x3a3a3a,1); g.strokeRect(-w/2,-h/2,w,h);
      if(pressed){ g.fillStyle(0x000000,0.10); g.fillRect(-w/2,-h/2,w,h); }
    };
    draw(false);

    const t=s.add.text(0,0,label,{
      fontFamily:'"Press Start 2P", monospace',
      fontSize:"10px",
      color:"#101010"
    }).setOrigin(0.5);

    c.add([g,t]);
    c.setSize(w,h);
    c.setInteractive(new Phaser.Geom.Rectangle(-w/2,-h/2,w,h), Phaser.Geom.Rectangle.Contains);
    c.on("pointerdown", ()=>{ draw(true); s.time.delayedCall(90,()=>draw(false)); onClick(); });
    return c;
  }

  // ============================
  // UTILS
  // ============================
  function setTotal(v){ total=Math.max(0,v); }
  function wait(ms){ return new Promise(r=>s.time.delayedCall(ms,r)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function rndi(a,b){ return Math.floor(rnd(a,b)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function fmt(v){ return Math.max(0,v).toFixed(DECIMALS); }

  function makeNice(v){
    let x=Math.max(0,v);
    const step = x<10?0.1:x<100?0.5:x<1000?1:x<10000?5:10;
    x=Math.ceil(x/step)*step;
    return Number(x.toFixed(DECIMALS));
  }

  function pickW(values, weights){
    const sum=weights.reduce((a,b)=>a+b,0);
    let r=Math.random()*sum;
    for(let i=0;i<values.length;i++){ r-=weights[i]; if(r<=0) return values[i]; }
    return values[values.length-1];
  }

})();
</script>
</body>
</html>
