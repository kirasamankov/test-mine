<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Block Bonus — Layout</title>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  <style>
    html,body{height:100%;margin:0;background:#79d0ff;overflow:hidden}
    body{display:flex;align-items:center;justify-content:center}
    #wrap{width:min(540px,98vw);display:flex;flex-direction:column;align-items:center;gap:10px;padding:10px;box-sizing:border-box}
    #game{width:100%;display:flex;align-items:center;justify-content:center}
    canvas{
      display:block;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius: 22px;
      box-shadow: 0 30px 90px rgba(0,0,0,.35);
      outline: 2px solid rgba(0,0,0,.25);
      background:#79d0ff;
    }
    #hud{
      width:100%;
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      background:rgba(0,0,0,.55);
      color:#fff;
      border-radius:14px;
      padding:10px 12px;
      font-family:"Press Start 2P", monospace;
      font-size:10px;
      user-select:none;
      box-sizing:border-box;
    }
    #hud.hidden{display:none}
    .grp{display:flex;align-items:center;gap:10px;flex-wrap:wrap}
    button{
      font-family:"Press Start 2P", monospace;
      font-size:10px;
      padding:8px 10px;
      border-radius:10px;
      border:0;
      cursor:pointer;
      background:#e9e9e9;
      color:#111;
    }
    button:active{transform:translateY(1px)}
    input[type="range"]{width:220px}
    .tiny{opacity:.85;font-size:8px}
    @media (max-width:420px){ input[type="range"]{width:160px} }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>

<body>
  <div id="wrap">
    <div id="game"></div>

    <!-- Панель ВНЕ кадра: можно не захватывать -->
    <div id="hud">
      <div class="grp">
        <button id="start">START</button>
        <button id="rec">REC</button>
        <span class="tiny">Space/Enter=Start • R=REC</span>
      </div>
      <div class="grp">
        <span>BET</span>
        <input id="bet" type="range" min="100" max="5000" step="100" value="1000" />
        <span id="betVal">1000</span>
      </div>
    </div>
  </div>

<script>
(() => {
  // ===============================
  // ЖЁСТКИЙ МАКЕТ: НЕ ЛОМАЕТСЯ
  // ===============================
  const W = 360, H = 640;

  const COLS = 5;         // <- 5 В ШИРИНУ ВЕЗДЕ
  const TOP_ROWS = 3;     // <- верхняя рамка 3 ряда
  const MINE_ROWS = 6;    // <- шахта 6 рядов
  const CELL = 48;        // 5*48=240 (ровно, красиво)
  const GRID_W = COLS * CELL; // 240
  const X0 = Math.floor((W - GRID_W) / 2); // 60

  // Вертикальные позиции (строго)
  const TOP_Y   = 20;                              // верхняя рамка
  const TOP_H   = TOP_ROWS * CELL;                 // 144
  const GAP_1   = 10;                              // зазор между рамкой и шахтой
  const MINE_Y  = TOP_Y + TOP_H + GAP_1;           // сразу под рамкой
  const MINE_H  = MINE_ROWS * CELL;                // 288
  const GAP_2   = 10;                              // зазор между шахтой и сундуками
  const CHEST_Y = MINE_Y + MINE_H + GAP_2;         // сразу под шахтой
  const CHEST_W = 44, CHEST_H = 44;                // твой ассет
  const SLAB_W  = 188, SLAB_H = 28;
  const SLAB_Y  = CHEST_Y + CHEST_H + 12;          // сразу под сундуками

  // Файлы ассетов
  const ASSETS = {
    panel: "assets/ui_panel.png",
    chestClosed: "assets/chest_closed.png",
    chestOpen: "assets/chest_open.png",
    slab: "assets/slab.png",
    grass: "assets/tile_grass.png",
    dirt: "assets/tile_dirt.png",
    iron: "assets/tile_iron.png",
  };

  // UI state
  let bet = 1000;
  let recMode = false;
  let total = 0;

  const game = new Phaser.Game({
    type: Phaser.CANVAS,
    parent: "game",
    width: W,
    height: H,
    backgroundColor: "#79d0ff",
    pixelArt: true,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: { preload, create }
  });

  function preload(){
    // Загружаем, но даже если нет — будет fallback (через try-catch нельзя тут,
    // просто проверим existence при create через textures.exists).
    this.load.image("panel", ASSETS.panel);
    this.load.image("chestC", ASSETS.chestClosed);
    this.load.image("chestO", ASSETS.chestOpen);
    this.load.image("slab", ASSETS.slab);
    this.load.image("grass", ASSETS.grass);
    this.load.image("dirt", ASSETS.dirt);
    this.load.image("iron", ASSETS.iron);
  }

  function create(){
    const s = this;

    bindHUD(s);

    drawSky(s);

    // 1) ВЕРХНЯЯ РАМКА 5x3 (сетка видна всегда)
    drawTopPanel(s);

    // 2) ШАХТА 5x6 (сетка видна всегда)
    drawMine(s);

    // 3) СУНДУКИ 5 штук, строго под шахтой (БЕЗ ЛИШНЕГО)
    drawChests(s);

    // 4) ПЛАШКА СЧЁТА (строго под сундуками)
    drawSlab(s);

    // Управление
    s.input.keyboard.on("keydown-SPACE", ()=>start());
    s.input.keyboard.on("keydown-ENTER", ()=>start());
    s.input.keyboard.on("keydown-R", ()=>toggleREC());

    function start(){
      // пока просто тест: увеличиваем сумму, чтобы видеть что работает
      total += bet * 1.23;
      updateSlabText(s);
    }
  }

  // ===============================
  // РЕНДЕР
  // ===============================
  function drawSky(s){
    // фон+облака (можно заменить твоим фоном позже)
    s.add.rectangle(W/2, H/2, W, H, 0x79d0ff).setDepth(-50);
    for(let i=0;i<8;i++){
      const x = rndi(0, W-80), y=rndi(40, 220), w=rndi(30, 60);
      const g=s.add.graphics().setDepth(-40);
      g.fillStyle(0xffffff,1);
      g.fillRect(x,y,w,12);
      g.fillRect(x+10,y-6,w,12);
      g.fillRect(x+20,y+2,w,12);
      g.fillStyle(0x000000,0.06);
      g.fillRect(x,y+10,w+22,3);
    }
    // земля низ
    const g=s.add.graphics().setDepth(-30);
    g.fillStyle(0x5fd23f,1).fillRect(0, H-120, W, 14);
    g.fillStyle(0xb8743c,1).fillRect(0, H-106, W, 140);
  }

  function drawTopPanel(s){
    if (s.textures.exists("panel")) {
      // если у тебя цельная рамка-ассет (5x3), просто рисуем
      const img = s.add.image(X0 + GRID_W/2, TOP_Y + TOP_H/2, "panel");
      img.setOrigin(0.5);
      img.setScale(GRID_W / img.width, TOP_H / img.height);
    } else {
      // fallback: рисуем рамку и сетку
      drawFrameWithGrid(s, X0, TOP_Y, GRID_W, TOP_H, COLS, TOP_ROWS);
    }
  }

  function drawMine(s){
    // фон шахты (тайлы), потом поверх сетка
    for(let r=0;r<MINE_ROWS;r++){
      for(let c=0;c<COLS;c++){
        const x = X0 + c*CELL;
        const y = MINE_Y + r*CELL;

        // Пример слоёв (ты потом скажешь точные)
        let tex = "dirt";
        if (r === 0) tex = "grass";
        if (r === 2) tex = "iron";

        if (s.textures.exists(tex)) {
          const img = s.add.image(x+CELL/2, y+CELL/2, tex);
          img.setScale(CELL / img.width, CELL / img.height);
        } else {
          // fallback блок
          const g=s.add.graphics();
          g.fillStyle(0xcfcfcf,1).fillRect(x,y,CELL,CELL);
        }
      }
    }

    // сетка всегда видна
    drawGridLines(s, X0, MINE_Y, GRID_W, MINE_H, COLS, MINE_ROWS, 0x000000, 0.55, 2);
  }

  function drawChests(s){
    for(let i=0;i<COLS;i++){
      // сундук должен стоять по центру каждой колонки
      const cx = X0 + i*CELL + CELL/2;
      const x  = cx - CHEST_W/2;
      const y  = CHEST_Y;

      if (s.textures.exists("chestC")) {
        const img = s.add.image(x + CHEST_W/2, y + CHEST_H/2, "chestC");
        img.setScale(CHEST_W / img.width, CHEST_H / img.height);
      } else {
        // fallback сундук
        const g=s.add.graphics();
        g.fillStyle(0xc9903a,1).fillRect(x,y,CHEST_W,CHEST_H);
        g.lineStyle(2,0x000000,0.35).strokeRect(x,y,CHEST_W,CHEST_H);
      }
    }
  }

  let slabTextObj = null;
  function drawSlab(s){
    const x = Math.floor((W - SLAB_W)/2);
    const y = SLAB_Y;

    if (s.textures.exists("slab")) {
      const img = s.add.image(x + SLAB_W/2, y + SLAB_H/2, "slab");
      img.setScale(SLAB_W / img.width, SLAB_H / img.height);
    } else {
      const g=s.add.graphics();
      g.fillStyle(0xbdbdbd,1).fillRect(x,y,SLAB_W,SLAB_H);
      g.lineStyle(2,0x6b6b6b,1).strokeRect(x,y,SLAB_W,SLAB_H);
    }

    slabTextObj = outlinedText(s, "0.00", W/2, y + SLAB_H/2 + 1, 14);
  }

  function updateSlabText(s){
    if(!slabTextObj) return;
    slabTextObj.setText(total.toFixed(2));
  }

  // ===============================
  // HUD / REC
  // ===============================
  function bindHUD(s){
    const hudEl = document.getElementById("hud");
    const betRange = document.getElementById("bet");
    const betVal = document.getElementById("betVal");
    const startBtn = document.getElementById("start");
    const recBtn = document.getElementById("rec");

    betRange.value = String(bet);
    betVal.textContent = String(bet);

    betRange.addEventListener("input", ()=>{
      bet = clamp(parseInt(betRange.value,10)||1000, 100, 5000);
      bet = Math.round(bet/100)*100;
      betVal.textContent = String(bet);
    });

    startBtn.addEventListener("click", ()=>{
      total += bet * 1.23;
      updateSlabText(s);
    });

    recBtn.addEventListener("click", ()=>toggleREC());

    function toggleREC(){
      recMode = !recMode;
      hudEl.classList.toggle("hidden", recMode);
    }
  }

  // ===============================
  // ПРИМИТИВЫ
  // ===============================
  function drawFrameWithGrid(s, x,y,w,h, cols,rows){
    const g=s.add.graphics();
    g.fillStyle(0xbfc3c7,1).fillRect(x,y,w,h);
    g.lineStyle(3,0x6b6b6b,1).strokeRect(x,y,w,h);
    g.lineStyle(2,0x8d8d8d,1).strokeRect(x+2,y+2,w-4,h-4);

    drawGridLines(s,x,y,w,h,cols,rows,0xffffff,0.9,2);
  }

  function drawGridLines(s, x,y,w,h, cols,rows, color, alpha, thickness){
    const g=s.add.graphics();
    g.lineStyle(thickness, color, alpha);
    const cw = w/cols, ch=h/rows;
    for(let c=1;c<cols;c++){
      const xx = x + c*cw;
      g.beginPath(); g.moveTo(xx, y+2); g.lineTo(xx, y+h-2); g.strokePath();
    }
    for(let r=1;r<rows;r++){
      const yy = y + r*ch;
      g.beginPath(); g.moveTo(x+2, yy); g.lineTo(x+w-2, yy); g.strokePath();
    }
    // обводка ячеек чёрным (как у тебя в шахте)
    const g2=s.add.graphics();
    g2.lineStyle(2, 0x000000, 0.38);
    for(let c=0;c<=cols;c++){
      const xx = x + c*cw;
      g2.beginPath(); g2.moveTo(xx, y); g2.lineTo(xx, y+h); g2.strokePath();
    }
    for(let r=0;r<=rows;r++){
      const yy = y + r*ch;
      g2.beginPath(); g2.moveTo(x, yy); g2.lineTo(x+w, yy); g2.strokePath();
    }
  }

  function outlinedText(s, text, x,y, size){
    const cont = s.add.container(x,y);
    const sh = s.add.text(2,2,text,{fontFamily:'"Press Start 2P", monospace',fontSize:`${size}px`,color:"#000"}).setOrigin(0.5);
    sh.setAlpha(0.8);
    const main = s.add.text(0,0,text,{fontFamily:'"Press Start 2P", monospace',fontSize:`${size}px`,color:"#fff"}).setOrigin(0.5);
    main.setShadow(2,2,"rgba(0,0,0,.55)",0,true,true);
    cont.add([sh,main]);

    cont.setText = (t)=>{ sh.setText(String(t)); main.setText(String(t)); };
    return cont;
  }

  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function rndi(a,b){ return Math.floor(a + Math.random()*(b-a)); }
})();
</script>
</body>
</html>
