<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Block Bonus (Content)</title>
  <style>
    html,body{height:100%;margin:0;background:#6cc8ff;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:10px}
    canvas{
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius:18px;
      box-shadow:0 30px 90px rgba(0,0,0,.35);
      outline: 2px solid rgba(0,0,0,.25);
      background:#6cc8ff;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>
<body>
<div id="wrap"></div>

<script>
(() => {
  // ====== –ù–ê–°–¢–†–û–ô–ö–ò ======
  const FREE_SPINS = 4;            // –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
  const CHEST_COUNT = 5;
  const DECIMALS = true;           // –∏—Ç–æ–≥ "327.00" –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
  const ALWAYS_GOOD_CHESTS = true; // "—Ö–æ—Ä–æ—à–∏–µ –º–Ω–æ–∂–∏—Ç–µ–ª–∏" —á–∞—â–µ

  // –°—Ç–∞–≤–∫–∞ –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º (–±–µ–∑ –≤–∞–ª—é—Ç—ã)
  const BET_MIN = 10;
  const BET_MAX = 5000;
  const BET_STEP = 10;

  // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ "–ø–∏–∫—Å–µ–ª—å–Ω–æ–µ" —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ
  const W = 360;
  const H = 640;

  // Layout (–ø–æ—Ö–æ–∂–µ –ø–æ —Ä–∞—Å–ø–æ–ª–æ–∂–µ–Ω–∏—é –Ω–∞ –≤–∏–¥–µ–æ)
  const TOP = { x: 38, y: 44, cols: 5, rows: 3, cw: 56, ch: 38, pad: 4 };   // 5x3
  const GRID = { x: 40, y: 190, cols: 5, rows: 6, cw: 56, ch: 56 };        // 5x6
  const CHEST_Y = 552;
  const SLAB_Y  = 602;

  // –°–∏–º–≤–æ–ª—ã —Å–≤–µ—Ä—Ö—É (–∫–∏—Ä–∫–∏ + –±–æ–Ω—É—Å-–æ—Ä–±)
  const SYMS = [
    { k:"P1", hits:1, icon:"‚õè", sub:"+1" },
    { k:"P2", hits:2, icon:"‚õè", sub:"+2" },
    { k:"P3", hits:3, icon:"‚õè", sub:"+3" },
    { k:"ORB",hits:0, icon:"‚óâ", sub:"BONUS" }
  ];

  // –ë–ª–æ–∫–∏ (—Å–≤–æ–∏, –Ω–æ –ø–æ—Ö–æ–∂–∏–µ –ø–æ —Å–ª–æ—è–º)
  const BLOCK_TYPES = [
    { key:"GRASS", hp:1, base:0x5fcf4a, accent:0x3ea536, pay:0.00 },
    { key:"DIRT",  hp:1, base:0xb4723a, accent:0x8d5524, pay:0.00 },
    { key:"STONE", hp:2, base:0x9aa0a8, accent:0x7d838a, pay:0.10 },
    { key:"RED",   hp:2, base:0xcfd2d6, accent:0xb82e2e, pay:0.20 },
    { key:"DIAM",  hp:3, base:0x44e1ff, accent:0x2fb9d2, pay:0.80 },
    { key:"GOLD",  hp:3, base:0xffd34a, accent:0xeab021, pay:0.60 },
    { key:"OBSI",  hp:4, base:0x2a2438, accent:0x1a1630, pay:2.50 }
  ];

  // ====== Phaser ======
  const game = new Phaser.Game({
    type: Phaser.AUTO,
    parent: "wrap",
    width: W,
    height: H,
    backgroundColor: "#6cc8ff",
    pixelArt: true,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: { create, update }
  });

  // ====== State ======
  let s;
  let topCells = [];
  let blocks = [];
  let chests = [];
  let overlay;

  let bet = 100;
  let total = 0;      // –∏—Ç–æ–≥ (–Ω–∞ —Å–µ—Ä–æ–π –ø–ª–∞—à–∫–µ)
  let totalDisp = 0;

  let running = false;
  let spinIndex = 0;

  // UI
  let startBtn, minusBtn, plusBtn, betText, slabText, fsText;

  function create(){
    s = this;

    drawSky(s);

    // –†–∞–º–∫–∞ —Å–≤–µ—Ä—Ö—É (reels)
    drawFrame(18, 34, W-36, 140);

    // 5x3
    buildTop();

    // –†–∞–º–∫–∞ –¥–ª—è –±–ª–æ–∫–æ–≤
    drawFrame(24, 182, W-48, 380);
    buildBlocks();

    // —Å—É–Ω–¥—É–∫–∏
    buildChests();

    // –Ω–∏–∂–Ω—è—è –ø–ª–∞—à–∫–∞ —Å—É–º–º—ã (–∫–∞–∫ –Ω–∞ –≤–∏–¥–µ–æ)
    buildSlab();

    // UI –≤—ã–±–æ—Ä–∞ —Å—Ç–∞–≤–∫–∏ + START (–∏ —Ç–æ–ª—å–∫–æ —ç—Ç–æ)
    buildBetUI();

    // overlay "BLOCK BONUS 4 FREE SPINS"
    overlay = buildOverlay();

    // –Ω–∞—á–∞–ª—å–Ω–æ–µ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–µ
    randomizeTop(false);
    updateSlab(0);
  }

  function update(){
    // –ø–ª–∞–≤–Ω–∞—è –∞–Ω–∏–º–∞—Ü–∏—è —Ü–∏—Ñ—Ä –Ω–∞ –ø–ª–∞—à–∫–µ
    totalDisp += (total - totalDisp) * 0.18;
    if (Math.abs(total-totalDisp) < 0.01) totalDisp = total;
    slabText.setText(fmtMoney(totalDisp));
  }

  // ====== UI ======
  function buildBetUI(){
    // –º–∞–ª–µ–Ω—å–∫–∞—è –ø–∞–Ω–µ–ª—å bet –Ω–∞–¥ START
    const y = SLAB_Y - 40;

    minusBtn = makePixelButton(W/2 - 110, y, 34, 28, "-", () => setBet(bet - BET_STEP));
    plusBtn  = makePixelButton(W/2 + 110, y, 34, 28, "+", () => setBet(bet + BET_STEP));

    const g = s.add.graphics();
    g.fillStyle(0xd6d6d6,1);
    g.fillRect(W/2-70, y-14, 140, 28);
    g.lineStyle(2, 0x6b6b6b, 1);
    g.strokeRect(W/2-70, y-14, 140, 28);

    betText = s.add.text(W/2, y, `BET: ${bet}`, {
      fontFamily:"monospace", fontSize:"12px", color:"#101010", fontStyle:"bold"
    }).setOrigin(0.5);

    // START (–µ–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è –±–æ–ª—å—à–∞—è –∫–Ω–æ–ø–∫–∞)
    startBtn = makePixelButton(W/2, y+34, 160, 34, "–°–¢–ê–†–¢", () => startBonus());
  }

  function setBet(v){
    if (running) return;
    bet = clamp(v, BET_MIN, BET_MAX);
    bet = Math.round(bet / BET_STEP) * BET_STEP;
    betText.setText(`BET: ${bet}`);
  }

  function buildSlab(){
    // —Å–µ—Ä–∞—è –ø–ª–∞—à–∫–∞ –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
    const g = s.add.graphics();
    g.fillStyle(0xbdbdbd, 1);
    g.fillRect(24, SLAB_Y, W-48, 30);
    g.lineStyle(2, 0x6b6b6b, 1);
    g.strokeRect(24, SLAB_Y, W-48, 30);

    slabText = s.add.text(W/2, SLAB_Y+7, "0.00", {
      fontFamily:"monospace", fontSize:"16px", color:"#0b0b0b", fontStyle:"bold"
    }).setOrigin(0.5,0);

    fsText = s.add.text(28, SLAB_Y-8, "", {
      fontFamily:"monospace", fontSize:"12px", color:"rgba(0,0,0,.55)", fontStyle:"bold"
    }).setOrigin(0,1);
  }

  function updateSlab(value){
    total = Math.max(0, value);
  }

  function buildOverlay(){
    const c = s.add.container(0,0).setDepth(999).setVisible(false);

    const dim = s.add.rectangle(W/2, H/2, W, H, 0x000000, 0.65);
    const box = s.add.graphics();
    box.fillStyle(0x0b0b0b, 0.75);
    box.fillRect(0, 0, W, H);
    box.clear(); // –ø–æ—Ç–æ–º —Ä–∏—Å—É–µ–º —Ç–µ–∫—Å—Ç–æ–º

    const title = s.add.text(W/2, H/2 - 30, "BLOCK BONUS", {
      fontFamily:"monospace", fontSize:"22px", color:"#ffffff", fontStyle:"bold"
    }).setOrigin(0.5);

    const big = s.add.text(W/2, H/2, `${FREE_SPINS} FREE SPINS`, {
      fontFamily:"monospace", fontSize:"26px", color:"#ffffff", fontStyle:"bold"
    }).setOrigin(0.5);

    const sub = s.add.text(W/2, H/2 + 32, "Blocks are persistent for 4 spins.", {
      fontFamily:"monospace", fontSize:"12px", color:"rgba(255,255,255,.75)", fontStyle:"bold"
    }).setOrigin(0.5);

    c.add([dim, title, big, sub]);

    c.setInteractive(new Phaser.Geom.Rectangle(0,0,W,H), Phaser.Geom.Rectangle.Contains);
    // —á—Ç–æ–±—ã –ø–æ —Ç–∞–ø—É –∑–∞–∫—Ä—ã–≤–∞—Ç—å (–∫–∞–∫ –±—É–¥—Ç–æ "–ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å")
    c.on("pointerdown", ()=>{ /* –Ω–∏—á–µ–≥–æ, —É–ø—Ä–∞–≤–ª—è–µ–º —Å–∞–º–∏ */ });

    c.show = () => {
      c.setVisible(true);
      c.setAlpha(0);
      s.tweens.add({targets:c, alpha:1, duration:180});
    };
    c.hide = () => {
      s.tweens.add({targets:c, alpha:0, duration:180, onComplete:()=>c.setVisible(false)});
    };

    return c;
  }

  // ====== BUILD TOP ======
  function buildTop(){
    for(let r=0;r<TOP.rows;r++){
      for(let c=0;c<TOP.cols;c++){
        const x = TOP.x + c*(TOP.cw+TOP.pad);
        const y = TOP.y + r*(TOP.ch+TOP.pad);
        topCells.push(makeTopCell(x,y,TOP.cw,TOP.ch,r,c));
      }
    }
  }

  function makeTopCell(x,y,w,h,r,c){
    const g = s.add.graphics();
    g.fillStyle(0xbfc5cc, 1);
    g.fillRect(x,y,w,h);
    g.lineStyle(2, 0x53575e, 1);
    g.strokeRect(x,y,w,h);

    const icon = s.add.text(x+w/2, y+h/2-2, "", {
      fontFamily:"monospace", fontSize:"18px", color:"#1a1a1a", fontStyle:"bold"
    }).setOrigin(0.5);

    const sub = s.add.text(x+w/2, y+h-10, "", {
      fontFamily:"monospace", fontSize:"10px", color:"#2d2d2d", fontStyle:"bold"
    }).setOrigin(0.5);

    return {x,y,w,h,r,c,g,icon,sub,sym:SYMS[0]};
  }

  function randomizeTop(forceBonus){
    topCells.forEach(cell=>{
      let sym;
      if(forceBonus && cell.r===0 && cell.c===2){
        sym = SYMS.find(z=>z.k==="ORB");
      } else {
        // –ø–æ—Ö–æ–∂–µ –Ω–∞ –≤–∏–¥–µ–æ: –º–Ω–æ–≥–æ –∫–∏—Ä–æ–∫, –∏–Ω–æ–≥–¥–∞ orb
        sym = pickWeighted([SYMS[0],SYMS[1],SYMS[2],SYMS[3]], [22,30,30,18]);
      }
      setTop(cell, sym);
    });
  }

  function setTop(cell, sym){
    cell.sym = sym;
    cell.icon.setText(sym.icon);
    cell.sub.setText(sym.sub);

    if(sym.k==="ORB"){
      cell.icon.setColor("#0b5cff");
      cell.sub.setColor("#0b5cff");
      pulseGlow(cell.x+cell.w/2, cell.y+cell.h/2, 16);
    } else {
      cell.icon.setColor("#1a1a1a");
      cell.sub.setColor("#2d2d2d");
    }
  }

  // ====== BLOCKS ======
  function buildBlocks(){
    blocks = [];
    for(let r=0;r<GRID.rows;r++){
      for(let c=0;c<GRID.cols;c++){
        const x = GRID.x + c*GRID.cw;
        const y = GRID.y + r*GRID.ch;
        const type = pickBlockLayer(r,c);
        blocks.push(makeBlock(x,y,GRID.cw,GRID.ch,r,c,type));
      }
    }
    refreshHpText();
  }

  function pickBlockLayer(r,c){
    // —Å–ª–æ–∏ –∫–∞–∫ –Ω–∞ –≤–∏–¥–µ–æ: –≤–µ—Ä—Ö –∑–µ–º–ª—è/–∫–∞–º–µ–Ω—å, –Ω–∏–∂–µ —Ä—É–¥–∞/–∞–ª–º–∞–∑—ã/–∑–æ–ª–æ—Ç–æ, –∏–Ω–æ–≥–¥–∞ –æ–±—Å–∏–¥–∏–∞–Ω
    if(r===0) return BLOCK_TYPES.find(t=>t.key==="GRASS");
    if(r===1) return BLOCK_TYPES.find(t=>t.key==="DIRT");
    if(r===2) return BLOCK_TYPES.find(t=>t.key==="STONE");
    if(r===3) return BLOCK_TYPES.find(t=>t.key==="RED");
    if(r===4) return (c<2 ? BLOCK_TYPES.find(t=>t.key==="DIAM") : BLOCK_TYPES.find(t=>t.key==="GOLD"));
    if(r===5) return (c===4 ? BLOCK_TYPES.find(t=>t.key==="OBSI") : pickWeighted(
      [BLOCK_TYPES.find(t=>t.key==="DIAM"), BLOCK_TYPES.find(t=>t.key==="GOLD"), BLOCK_TYPES.find(t=>t.key==="STONE")],
      [28, 45, 27]
    ));
    return BLOCK_TYPES.find(t=>t.key==="STONE");
  }

  function makeBlock(x,y,w,h,r,c,type){
    const g = s.add.graphics();
    drawBlock(g,x,y,w,h,type);

    const hpText = s.add.text(x+4,y+4,"",{
      fontFamily:"monospace", fontSize:"10px", color:"rgba(0,0,0,.65)", fontStyle:"bold"
    });

    return {x,y,w,h,r,c,type,hp:type.hp,alive:true,g,hpText};
  }

  function drawBlock(g,x,y,w,h,type){
    g.fillStyle(type.base,1);
    g.fillRect(x,y,w,h);

    // –ø–∏–∫—Å–µ–ª—å–Ω—ã–µ –≤–∫—Ä–∞–ø–ª–µ–Ω–∏—è
    for(let i=0;i<10;i++){
      g.fillStyle(type.accent,0.9);
      g.fillRect(x+rndi(2,w-6), y+rndi(2,h-6), 2, 2);
    }

    // —Ä–∞–º–∫–∞
    g.lineStyle(2, 0x000000, 0.22);
    g.strokeRect(x,y,w,h);

    // –±–ª–∏–∫
    g.fillStyle(0xffffff, 0.10);
    g.fillRect(x+2,y+2,w-4,6);

    if(type.key==="GRASS"){
      g.fillStyle(0x56c83f,1);
      g.fillRect(x,y,w,10);
    }
    if(type.key==="RED"){
      g.fillStyle(0xb82e2e,1);
      g.fillRect(x,y+h-10,w,10);
    }
  }

  function refreshHpText(){
    blocks.forEach(b => b.hpText.setText(b.alive ? `HP:${b.hp}` : ""));
  }

  // ====== CHESTS ======
  function buildChests(){
    chests = [];
    const startX = 28;
    const cw = 60;
    for(let i=0;i<CHEST_COUNT;i++){
      const x = startX + i*(cw+6);
      const y = CHEST_Y;
      chests.push(makeChest(x,y,cw,38,i));
    }
  }

  function makeChest(x,y,w,h,i){
    const g = s.add.graphics();
    drawChest(g,x,y,w,h,false);
    const lock = s.add.text(x+w/2, y+h/2+1, "üîí", {fontFamily:"monospace", fontSize:"12px"}).setOrigin(0.5);
    return {x,y,w,h,i,g,lock,opened:false};
  }

  function drawChest(g,x,y,w,h,opened){
    g.clear();
    g.fillStyle(0xc9903a,1);
    g.fillRect(x,y,w,h);
    g.fillStyle(0xa86e2c,1);
    g.fillRect(x,y,w,12);

    for(let k=0;k<4;k++){
      g.fillStyle(0x000000,0.10);
      g.fillRect(x+6+k*14, y, 2, h);
    }
    g.lineStyle(2,0x000000,0.22);
    g.strokeRect(x,y,w,h);

    if(opened){
      g.fillStyle(0x000000,0.18);
      g.fillRect(x, y-10, w, 10);
    }
  }

  function resetChests(){
    chests.forEach(c=>{
      c.opened=false;
      drawChest(c.g,c.x,c.y,c.w,c.h,false);
      c.lock.setText("üîí").setAlpha(1);
    });
  }

  // ====== FLOW: START -> overlay -> 4 spins -> chests -> end ======
  async function startBonus(){
    if(running) return;
    running = true;

    // –±–ª–æ–∫–∏—Ä—É–µ–º UI
    startBtn.disableInteractive();
    minusBtn.disableInteractive();
    plusBtn.disableInteractive();

    // reset
    spinIndex = 0;
    total = 0;
    totalDisp = 0;
    updateSlab(0);
    resetChests();

    // –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –±–ª–æ–∫–∏ (–æ–Ω–∏ –±—É–¥—É—Ç persistent –Ω–∞ 4 —Å–ø–∏–Ω–∞)
    blocks.forEach(b=>{
      b.alive=true;
      b.type = pickBlockLayer(b.r,b.c);
      b.hp = b.type.hp;
      b.g.clear();
      drawBlock(b.g,b.x,b.y,b.w,b.h,b.type);
      b.hpText.setAlpha(1);
    });
    refreshHpText();

    // –ø–æ–∫–∞–∑–∞—Ç—å overlay –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
    overlay.show();
    await wait(900);
    overlay.hide();
    await wait(250);

    // –∑–∞–ø—É—Å–∫–∞–µ–º 4 —Å–ø–∏–Ω–∞ –ø–æ–¥—Ä—è–¥
    for(let i=0;i<FREE_SPINS;i++){
      spinIndex = i+1;
      fsText.setText(`FREE SPIN ${spinIndex}/${FREE_SPINS}`);
      await doOneSpin();
      await wait(250);
    }

    fsText.setText("");

    // —Ñ–∞–∑–∞ —Å—É–Ω–¥—É–∫–æ–≤: –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª–∏ –∏ —Å—á–∏—Ç–∞–µ–º –∏—Ç–æ–≥
    await doChestsPhase();

    // —Ñ–∏–Ω–∞–ª
    running = false;
    startBtn.setInteractive();
    minusBtn.setInteractive();
    plusBtn.setInteractive();
  }

  async function doOneSpin(){
    // 1) reel-spin –∞–Ω–∏–º–∞—Ü–∏—è
    await reelSpin();

    // 2) —Å—á–∏—Ç–∞–µ–º —É–¥–∞—Ä—ã –ø–æ –∫–æ–ª–æ–Ω–∫–∞–º
    const hits = [0,0,0,0,0];
    let sawOrb = false;
    topCells.forEach(cell=>{
      hits[cell.c] += cell.sym.hits;
      if(cell.sym.k==="ORB") sawOrb=true;
    });

    // –≤ –±–æ–Ω—É—Å–µ —É–¥–∞—Ä—ã "–ø—Ä–∏—è—Ç–Ω–µ–µ" (–∫–∞–∫ –æ—â—É—â–∞–µ—Ç—Å—è –Ω–∞ –≤–∏–¥–µ–æ)
    for(let i=0;i<5;i++){
      hits[i] += rndi(1,4);
    }

    // 3) –ø—Ä–∏–º–µ–Ω—è–µ–º —É–¥–∞—Ä—ã —Å–≤–µ—Ä—Ö—É –≤–Ω–∏–∑ (–±–ª–æ–∫–∏ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è –º–µ–∂–¥—É —Å–ø–∏–Ω–∞–º–∏!)
    for(let col=0; col<5; col++){
      let left = hits[col];
      for(let row=0; row<6; row++){
        if(left<=0) break;
        const b = blocks.find(z=>z.c===col && z.r===row);
        if(!b || !b.alive) continue;

        await hitBlock(b);
        left--;
      }
    }
    refreshHpText();
  }

  function reelSpin(){
    return new Promise(resolve=>{
      const t0 = s.time.now;
      const dur = 650;
      const ev = s.time.addEvent({
        delay: 55,
        loop: true,
        callback: ()=>{
          randomizeTop(false);
          topCells.forEach(c=> c.icon.y = (c.y + c.h/2 - 2) + rndi(-1,2));

          if(s.time.now - t0 >= dur){
            ev.remove(false);
            // —Ñ–∏–Ω–∞–ª—å–Ω—ã–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç: —á–∞—Å—Ç–æ ORB –∫–∞–∫ –Ω–∞ —Ä–æ–ª–∏–∫–µ
            randomizeTop(true);
            topCells.forEach(c=> c.icon.y = (c.y + c.h/2 - 2));
            resolve();
          }
        }
      });
    });
  }

  function hitBlock(b){
    return new Promise(resolve=>{
      b.hp -= 1;

      // ‚Äú–ø—ã–ª—å/—á–∞—Å—Ç–∏—Ü—ã‚Äù
      pixelBurst(b.x+b.w/2, b.y+b.h/2, b.type.accent);

      // —Ç—Ä–µ—â–∏–Ω–∞
      const crack = s.add.graphics();
      crack.lineStyle(2, 0x000000, 0.22);
      crack.beginPath();
      crack.moveTo(b.x + rndi(6,b.w-6), b.y + rndi(6,b.h-6));
      crack.lineTo(b.x + rndi(6,b.w-6), b.y + rndi(6,b.h-6));
      crack.strokePath();
      s.time.delayedCall(120, ()=> crack.destroy());

      if(b.hp <= 0){
        b.alive = false;

        // –¥–æ–±–∞–≤–ª—è–µ–º –∫ —Å—É–º–º–µ (–±–µ–∑ –≤–∞–ª—é—Ç—ã, –∫–∞–∫ –≤ –≤–∏–¥–µ–æ)
        const add = bet * b.type.pay;
        updateSlab(total + add);

        // ‚Äú—Ä–∞–∑—Ä—É—à–µ–Ω–∏–µ‚Äù
        s.time.delayedCall(80, ()=>{
          b.g.clear();
          b.g.fillStyle(0x000000, 0.06);
          b.g.fillRect(b.x,b.y,b.w,b.h);
          b.g.lineStyle(1, 0x000000, 0.12);
          b.g.strokeRect(b.x,b.y,b.w,b.h);
        });

        s.tweens.add({targets:b.hpText, alpha:0, duration:140});
      } else {
        b.hpText.setText(`HP:${b.hp}`);
      }

      s.time.delayedCall(130, resolve);
    });
  }

  async function doChestsPhase(){
    // –∫–∞–∫ –≤ –≤–∏–¥–µ–æ: —Å—É–Ω–¥—É–∫–∏ –æ—Ç–∫—Ä—ã–≤–∞—é—Ç—Å—è –∏ –¥–∞—é—Ç –º–Ω–æ–∂–∏—Ç–µ–ª–∏, –∏—Ç–æ–≥ —Ä–µ–∑–∫–æ —Ä–∞—Å—Ç—ë—Ç

    // —Å–ª–µ–≥–∫–∞ ‚Äú—Å–æ–±–∏—Ä–∞–µ–º‚Äù –±–∞—à–Ω—é –ø–æ —Ü–µ–Ω—Ç—Ä—É (—É–ø—Ä–æ—â—ë–Ω–Ω–æ: –≤–∏–∑—É–∞–ª—å–Ω–æ –æ—Å—Ç–∞–≤–ª—è–µ–º, –Ω–æ —ç—Ñ—Ñ–µ–∫—Ç –¥–æ–±–∞–≤–∏–º)
    // –ü—Ä–æ—Å—Ç–æ –ø–∞—É–∑–∞, —á—Ç–æ–±—ã –≤—ã–≥–ª—è–¥–µ–ª–æ –∫–∞–∫ –ø–µ—Ä–µ—Ö–æ–¥.
    await wait(350);

    // –û—Ç–∫—Ä—ã–≤–∞–µ–º –≤—Å–µ 5 —Å—É–Ω–¥—É–∫–æ–≤, –ø–æ–∫–∞–∑—ã–≤–∞–µ–º xN –Ω–∞–¥ –∫–∞–∂–¥—ã–º
    // –∏ –ø—Ä–∏–º–µ–Ω—è–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª—å –∫ –Ω–∞–∫–æ–ø–ª–µ–Ω–Ω–æ–π —Å—É–º–º–µ.
    let current = total;

    for(let i=0;i<CHEST_COUNT;i++){
      const c = chests[i];
      c.opened = true;
      c.lock.setAlpha(0);
      drawChest(c.g,c.x,c.y,c.w,c.h,true);

      const mul = pickChestMultiplier(i);

      // –ø–æ–∫–∞–∑–∞—Ç—å xN
      const txt = s.add.text(c.x+c.w/2, c.y-10, `x${mul}`, {
        fontFamily:"monospace",
        fontSize:"16px",
        color:"#0b0b0b",
        fontStyle:"bold",
        backgroundColor:"rgba(255,255,255,.65)",
        padding:{left:6,right:6,top:2,bottom:2}
      }).setOrigin(0.5);

      // ‚Äú–ø–æ–¥–ø—Ä—ã–≥–∏–≤–∞–Ω–∏–µ‚Äù
      s.tweens.add({targets:txt, y:txt.y-10, duration:180, yoyo:true});

      pixelBurst(c.x+c.w/2, c.y+8, 0xffd34a);

      // –ø—Ä–∏–º–µ–Ω—è–µ–º –º–Ω–æ–∂–∏—Ç–µ–ª—å (–∫–∞–∫ –≤ –≤–∏–¥–µ–æ: –º—É–ª—å—Ç—ã –Ω–∞ —Å—É–Ω–¥—É–∫–∞—Ö)
      current = current * mul;

      // –ø–ª–∞–≤–Ω–æ –¥–æ–∫—Ä—É—Ç–∏—Ç—å —Å—É–º–º—É
      updateSlab(current);

      await wait(420);
      s.tweens.add({targets:txt, alpha:0, duration:520, delay:400, onComplete:()=>txt.destroy()});
    }

    // —Ñ–∏–Ω–∞–ª—å–Ω–æ–µ ‚Äú–∫—Ä–∞—Å–∏–≤–æ–µ‚Äù –æ–∫—Ä—É–≥–ª–µ–Ω–∏–µ –ø–æ–¥ –∫–æ–Ω—Ç–µ–Ω—Ç
    const nice = makeNice(current);
    updateSlab(nice);

    await wait(500);
  }

  function pickChestMultiplier(i){
    // ‚Äú—Ö–æ—Ä–æ—à–∏–µ –º–Ω–æ–∂–∏—Ç–µ–ª–∏‚Äù (–ø–æ –ø—Ä–æ—Å—å–±–µ)
    // –ù–∞ –≤–∏–¥–µ–æ —á–∞—Å—Ç–æ x2/x2/x2‚Ä¶ –Ω–æ –º–æ–∂–Ω–æ –¥–∞–≤–∞—Ç—å –∏ –≤—ã—à–µ.
    if(ALWAYS_GOOD_CHESTS){
      // —á—É—Ç—å —á–∞—â–µ x2/x3, –∏–Ω–æ–≥–¥–∞ x5/x10/x20
      return pickWeighted([2,2,2,3,3,5,10,20], [22,22,18,14,12,8,3,1]);
    }
    return pickWeighted([2,3,5,8,10], [50,25,15,7,3]);
  }

  // ====== helpers / drawing ======
  function drawFrame(x,y,w,h){
    const g = s.add.graphics();
    g.fillStyle(0xd6d6d6,1);
    g.fillRect(x,y,w,h);
    g.lineStyle(3, 0x6b6b6b, 1);
    g.strokeRect(x,y,w,h);
    g.lineStyle(1, 0xffffff, 0.35);
    g.strokeRect(x+2,y+2,w-4,h-4);
  }

  function drawSky(scene){
    const bg = scene.add.graphics();
    bg.fillStyle(0x6cc8ff,1);
    bg.fillRect(0,0,W,H);

    for(let i=0;i<8;i++){
      drawCloud(rndi(10,W-70), rndi(10,170), rndi(20,34));
    }

    const g = scene.add.graphics();
    g.fillStyle(0x56c83f,1);
    g.fillRect(0, H-30, W, 10);
    g.fillStyle(0xb4723a,1);
    g.fillRect(0, H-20, W, 20);
    g.fillStyle(0x000000,0.12);
    g.fillRect(0, H-30, W, 30);
  }

  function drawCloud(x,y,size){
    const g = s.add.graphics();
    g.fillStyle(0xffffff, 1);
    g.fillRect(x, y, size, size/2);
    g.fillRect(x+8, y-6, size, size/2);
    g.fillRect(x+16, y+2, size, size/2);
    g.fillStyle(0x000000, 0.08);
    g.fillRect(x, y+size/2-2, size+16, 3);
  }

  function makePixelButton(x,y,w,h,text,onClick){
    const c = s.add.container(x,y);
    const g = s.add.graphics();

    const draw = (pressed=false) => {
      g.clear();
      g.fillStyle(0xb7b7b7, 1);
      g.fillRect(-w/2, -h/2, w, h);
      g.fillStyle(0x8f8f8f, 1);
      g.fillRect(-w/2, -h/2, w, 6);
      g.fillStyle(0xd7d7d7, 1);
      g.fillRect(-w/2, h/2-6, w, 6);
      g.lineStyle(2, 0x3a3a3a, 1);
      g.strokeRect(-w/2, -h/2, w, h);
      if(pressed){
        g.fillStyle(0x000000, 0.08);
        g.fillRect(-w/2, -h/2, w, h);
      }
    };
    draw(false);

    const t = s.add.text(0,0,text,{fontFamily:"monospace",fontSize:"16px",color:"#101010",fontStyle:"bold"}).setOrigin(0.5);
    c.add([g,t]);
    c.setSize(w,h);
    c.setInteractive(new Phaser.Geom.Rectangle(-w/2,-h/2,w,h), Phaser.Geom.Rectangle.Contains);
    c.on("pointerdown", ()=>{ draw(true); s.time.delayedCall(90, ()=>draw(false)); onClick(); });
    return c;
  }

  function pixelBurst(x,y,color){
    for(let i=0;i<10;i++){
      const p = s.add.rectangle(x,y,2,2,color,1);
      const dx = rnd(-30,30);
      const dy = rnd(-30,30);
      s.tweens.add({
        targets:p,
        x:x+dx, y:y+dy,
        alpha:{from:1,to:0},
        duration:260,
        onComplete:()=>p.destroy()
      });
    }
  }

  function pulseGlow(x,y,r){
    const g = s.add.graphics();
    g.fillStyle(0x2aa8ff, 0.35);
    g.fillCircle(x,y,r);
    s.tweens.add({targets:g, alpha:{from:0.45,to:0.1}, duration:500, yoyo:true, repeat:2, onComplete:()=>g.destroy()});
  }

  function fmtMoney(v){
    if(!DECIMALS){
      return String(Math.floor(v)).replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
    // 2 –∑–Ω–∞–∫–∞ –∫–∞–∫ "327.00"
    const fixed = (Math.round(v*100)/100).toFixed(2);
    // –±–µ–∑ –≤–∞–ª—é—Ç—ã
    return fixed;
  }

  function makeNice(v){
    // ‚Äú–∫—Ä–∞—Å–∏–≤–æ–µ‚Äù —á–∏—Å–ª–æ: —Å–ª–µ–≥–∫–∞ –ø–æ–¥–≥–æ–Ω—è–µ–º –∫ .00 –∏ –ø—Ä–∏—è—Ç–Ω–æ–º—É –¥–∏–∞–ø–∞–∑–æ–Ω—É
    let x = Math.max(0, v);
    // –ø–æ–¥–Ω–∏–º–µ–º –¥–æ "–∫—Ä–∞—Å–∏–≤–æ–≥–æ" –¥–µ—Å—è—Ç–∫–∞/—Å–æ—Ç–Ω–∏
    const step = x < 100 ? 1 : x < 1000 ? 5 : x < 10000 ? 10 : 25;
    x = Math.ceil(x/step)*step;
    // –∏ .00
    return DECIMALS ? Math.round(x*100)/100 : Math.round(x);
  }

  function wait(ms){ return new Promise(r=>s.time.delayedCall(ms,r)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function rndi(a,b){ return Math.floor(rnd(a,b)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function pickWeighted(values, weights){
    const sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random()*sum;
    for(let i=0;i<values.length;i++){
      r -= weights[i];
      if(r<=0) return values[i];
    }
    return values[values.length-1];
  }

})();
</script>
</body>
</html>
