<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Block Bonus (Content)</title>
  <style>
    html,body{height:100%;margin:0;background:#6cc8ff;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:10px}
    canvas{
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      border-radius:18px;
      box-shadow:0 30px 90px rgba(0,0,0,.35);
      outline: 2px solid rgba(0,0,0,.25);
      background:#6cc8ff;
    }
  </style>
  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>
<body>
<div id="wrap"></div>

<script>
(() => {
  // =========================
  // –ù–ê–°–¢–†–û–ô–ö–ò –ü–û–î –¢–í–û–Å –í–ò–î–ï–û
  // =========================
  const FREE_SPINS = 4;
  const CHESTS_TOTAL = 5;

  // –û—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è 3..5 —Å—É–Ω–¥—É–∫–æ–≤
  const OPEN_MIN = 3;
  const OPEN_MAX = 5;

  // –ò—Ç–æ–≥ –≤—Å–µ–≥–¥–∞ —Å —Ç–æ—á–∫–æ–π
  const DECIMALS = 2; // "327.00"

  // "—Å–ª—É–∂–µ–±–Ω–∞—è –∑–æ–Ω–∞" —Å–Ω–∏–∑—É (—á—Ç–æ–±—ã –µ—ë –æ–±—Ä–µ–∑–∞—Ç—å –ø—Ä–∏ –∑–∞–ø–∏—Å–∏)
  // –í—Å—ë —É–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –±—É–¥–µ—Ç —Ç–æ–ª—å–∫–æ —Ç—É—Ç.
  const SAFE_CROP_H = 86;

  // BET –≤—ã–±–∏—Ä–∞–µ—Ç—Å—è, –≤–∞–ª—é—Ç—ã –ù–ï–¢
  const BET_MIN = 10;
  const BET_MAX = 5000;
  const BET_STEP = 10;

  // –í–Ω—É—Ç—Ä–µ–Ω–Ω–µ–µ –ø–∏–∫—Å–µ–ª—å–Ω–æ–µ —Ä–∞–∑—Ä–µ—à–µ–Ω–∏–µ (9:16)
  const W = 360;
  const H = 640;

  // –ê–∫—Ç–∏–≤–Ω–∞—è –æ–±–ª–∞—Å—Ç—å –∏–≥—Ä—ã (–∫–∞–∫ –Ω–∞ –≤–∏–¥–µ–æ) ‚Äî –í–´–®–ï safe-crop –∑–æ–Ω—ã
  const GAME_H = H - SAFE_CROP_H;

  // Layout (–ø–æ–¥–æ–≥–Ω–∞–Ω–æ, —á—Ç–æ–±—ã –≤—ã–≥–ª—è–¥–µ–ª–æ –∫–∞–∫ –Ω–∞ —Ä–æ–ª–∏–∫–µ)
  const TOP = { x: 36, y: 36, cols: 5, rows: 3, cw: 56, ch: 38, pad: 4 };
  const GRID = { x: 40, y: 180, cols: 5, rows: 6, cw: 56, ch: 56 };
  const CHEST_Y = 520;
  const SLAB_Y  = 574;  // —Å–µ—Ä—ã–π –∏—Ç–æ–≥–æ–≤—ã–π –±–∞—Ä (–æ–Ω –≤ –∑–æ–Ω–µ –∏–≥—Ä—ã, –ù–ï –≤ safe-crop)

  // ===== –°–∏–º–≤–æ–ª—ã =====
  const SYMS = [
    { k:"P1", hits:1, icon:"‚õè", sub:"+1" },
    { k:"P2", hits:2, icon:"‚õè", sub:"+2" },
    { k:"P3", hits:3, icon:"‚õè", sub:"+3" },
    { k:"ORB",hits:0, icon:"‚óâ", sub:"BONUS" }
  ];

  // ===== –ë–ª–æ–∫–∏ =====
  const BLOCK_TYPES = [
    { key:"GRASS", hp:1, base:0x5fcf4a, accent:0x3ea536, pay:0.00 },
    { key:"DIRT",  hp:1, base:0xb4723a, accent:0x8d5524, pay:0.00 },
    { key:"STONE", hp:2, base:0x9aa0a8, accent:0x7d838a, pay:0.10 },
    { key:"RED",   hp:2, base:0xcfd2d6, accent:0xb82e2e, pay:0.20 },
    { key:"DIAM",  hp:3, base:0x44e1ff, accent:0x2fb9d2, pay:0.80 },
    { key:"GOLD",  hp:3, base:0xffd34a, accent:0xeab021, pay:0.60 },
    { key:"OBSI",  hp:4, base:0x2a2438, accent:0x1a1630, pay:2.50 }
  ];

  // ===== Phaser =====
  new Phaser.Game({
    type: Phaser.AUTO,
    parent: "wrap",
    width: W,
    height: H,
    backgroundColor: "#6cc8ff",
    pixelArt: true,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: { create, update }
  });

  // ===== State =====
  let s;
  let topCells = [];
  let blocks = [];
  let chests = [];
  let overlay;
  let guide; // –ª–∏–Ω–∏—è "–º–æ–∂–Ω–æ –æ–±—Ä–µ–∑–∞—Ç—å" (–ø–æ–º–æ–≥–∞–µ—Ç)
  let running = false;

  let bet = 100;

  let total = 0;
  let totalDisp = 0;
  let spinIndex = 0;

  // UI (–≤ safe-crop –∑–æ–Ω–µ)
  let btnStart, btnMinus, btnPlus, betText;

  // slab
  let slabText, fsText;

  function create(){
    s = this;

    drawSky();

    // –õ–∏–Ω–∏—è –ø–æ–¥—Å–∫–∞–∑–∫–∏, –≥–¥–µ –æ–±—Ä–µ–∑–∞—Ç—å (–º–æ–∂–µ—à—å –≤—ã–∫–ª—é—á–∏—Ç—å –≤ –∫–æ–¥–µ: guide.setVisible(false))
    guide = s.add.graphics();
    guide.lineStyle(2, 0x000000, 0.15);
    guide.beginPath();
    guide.moveTo(0, GAME_H);
    guide.lineTo(W, GAME_H);
    guide.strokePath();
    const gtxt = s.add.text(W-6, GAME_H-6, "CROP BELOW", {fontFamily:"monospace",fontSize:"10px",color:"rgba(0,0,0,.35)",fontStyle:"bold"}).setOrigin(1,1);

    // –†–∞–º–∫–∏ –≤ "–∏–≥—Ä–æ–≤–æ–π –∑–æ–Ω–µ"
    drawFrame(18, 26, W-36, 140);
    drawFrame(24, 172, W-48, 360);

    // reels + blocks
    buildTop();
    buildBlocks();

    // —Å—É–Ω–¥—É–∫–∏ (–≤ –∏–≥—Ä–æ–≤–æ–π –∑–æ–Ω–µ)
    buildChests();

    // –∏—Ç–æ–≥–æ–≤–∞—è –ø–ª–∞—à–∫–∞ (–≤ –∏–≥—Ä–æ–≤–æ–π –∑–æ–Ω–µ)
    buildSlab();

    // UI –≤ safe-crop –∑–æ–Ω–µ (–º–æ–∂–Ω–æ –æ–±—Ä–µ–∑–∞—Ç—å –∏ –µ–≥–æ –Ω–µ –±—É–¥–µ—Ç –≤–∏–¥–Ω–æ)
    buildSafeUI();

    // overlay –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
    overlay = buildOverlay();

    randomizeTop(true);
    setTotal(0);
  }

  function update(){
    totalDisp += (total - totalDisp) * 0.18;
    if (Math.abs(total-totalDisp) < 0.005) totalDisp = total;
    slabText.setText(fmt(totalDisp));
  }

  // =========================
  // FLOW: START -> overlay -> 4 spins -> open 3..5 chests -> finish
  // =========================
  async function startBonus(){
    if(running) return;
    running = true;

    lockUI(true);

    spinIndex = 0;
    setTotal(0);
    resetChests();
    resetBlocksPersistent();

    // overlay
    overlay.show();
    await wait(900);
    overlay.hide();
    await wait(250);

    // 4 spins
    for(let i=0;i<FREE_SPINS;i++){
      spinIndex = i+1;
      fsText.setText(`FREE SPIN ${spinIndex}/${FREE_SPINS}`);
      await doOneSpin();
      await wait(240);
    }
    fsText.setText("");

    // —Å—É–Ω–¥—É–∫–∏ 3..5
    await doChestsPhase();

    // –∫–æ–Ω–µ—Ü
    running = false;
    lockUI(false);
  }

  async function doOneSpin(){
    await reelSpin();
    const hits = [0,0,0,0,0];

    topCells.forEach(cell => { hits[cell.c] += cell.sym.hits; });

    // –¥–µ–ª–∞–µ–º, —á—Ç–æ–±—ã –≤ –±–æ–Ω—É—Å–µ –≤—Å–µ–≥–¥–∞ –±—ã–ª–æ ‚Äú–¥–≤–∏–∂–µ–Ω–∏–µ‚Äù –∫–∞–∫ –Ω–∞ –≤–∏–¥–µ–æ
    for(let i=0;i<5;i++) hits[i] += rndi(1,4);

    for(let col=0; col<5; col++){
      let left = hits[col];
      for(let row=0; row<6; row++){
        if(left<=0) break;
        const b = blocks.find(z => z.c===col && z.r===row);
        if(!b || !b.alive) continue;
        await hitBlock(b);
        left--;
      }
    }
    refreshHp();
  }

  async function doChestsPhase(){
    await wait(260);

    // –°–∫–æ–ª—å–∫–æ —Å—É–Ω–¥—É–∫–æ–≤ –æ—Ç–∫—Ä–æ–µ–º (3..5)
    const openCount = rndi(OPEN_MIN, OPEN_MAX+1);

    // –ß–µ–º –º–µ–Ω—å—à–µ —Å—É–Ω–¥—É–∫–æ–≤, —Ç–µ–º –≤—ã—à–µ –º—É–ª—å—Ç—ã (–∫–∞–∫ —Ç—ã –ø—Ä–æ—Å–∏–ª)
    // openCount=3 => –±–æ–ª—å—à–µ –≤–µ—Ä–æ—è—Ç–Ω–æ—Å—Ç—å 10..50
    // openCount=5 => —á–∞—â–µ 2..10
    const pool = (openCount === 3)
      ? { values:[5,10,12,15,20,25,30,40,50], weights:[6,14,14,14,14,12,10,8,8] }
      : (openCount === 4)
      ? { values:[2,3,5,8,10,12,15,20,25], weights:[18,16,16,14,12,10,8,4,2] }
      : { values:[2,2,3,3,5,5,8,10,12], weights:[22,20,16,14,12,8,5,2,1] };

    // –í—ã–±–∏—Ä–∞–µ–º –∫–∞–∫–∏–µ —Å—É–Ω–¥—É–∫–∏ –æ—Ç–∫—Ä–æ—é—Ç—Å—è (—Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ –¥–ª—è ‚Äú–∫–∞–∫ –≤ —Ä–æ–ª–∏–∫–µ‚Äù)
    // –ú–æ–∂–Ω–æ —Å–¥–µ–ª–∞—Ç—å —Å–ª—É—á–∞–π–Ω—ã–µ ‚Äî –Ω–æ –≤–∏–¥–µ–æ –æ–±—ã—á–Ω–æ —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ.
    const openIdx = [];
    for(let i=0;i<openCount;i++) openIdx.push(i);

    // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ: –º–Ω–æ–∂–∏—Ç–µ–ª–∏ ‚Äú–Ω–∞–∫—Ä—É—á–∏–≤–∞—é—Ç‚Äù —Ç–µ–∫—É—â–∏–π total
    let current = total;

    for(let k=0;k<openIdx.length;k++){
      const i = openIdx[k];
      const c = chests[i];
      c.opened = true;
      c.lock.setAlpha(0);
      drawChest(c.g, c.x,c.y,c.w,c.h,true);

      const mul = pickWeighted(pool.values, pool.weights);

      // –Ω–∞–¥–ø–∏—Å—å xN
      const txt = s.add.text(c.x+c.w/2, c.y-10, `x${mul}`, {
        fontFamily:"monospace",
        fontSize:"16px",
        color:"#0b0b0b",
        fontStyle:"bold",
        backgroundColor:"rgba(255,255,255,.65)",
        padding:{left:6,right:6,top:2,bottom:2}
      }).setOrigin(0.5);

      s.tweens.add({targets:txt, y:txt.y-10, duration:180, yoyo:true});
      pixelBurst(c.x+c.w/2, c.y+8, 0xffd34a);

      // –º–Ω–æ–∂–∏—Ç–µ–ª—å –ø—Ä–∏–º–µ–Ω—è–µ–º –∫ total
      current = current * mul;
      setTotal(current);

      await wait(420);
      s.tweens.add({targets:txt, alpha:0, duration:520, delay:360, onComplete:()=>txt.destroy()});
    }

    // –ï—Å–ª–∏ –æ—Ç–∫—Ä—ã–ª–æ—Å—å –º–µ–Ω—å—à–µ 5 —Å—É–Ω–¥—É–∫–æ–≤ ‚Äî –æ—Å—Ç–∞–ª—å–Ω—ã–µ –æ—Å—Ç–∞—é—Ç—Å—è –∑–∞–∫—Ä—ã—Ç—ã–º–∏ (–∫–∞–∫ –ø—Ä–æ—Å–∏—à—å)
    // –§–∏–Ω–∞–ª—å–Ω—ã–π "nice"
    setTotal(makeNice(current));
    await wait(450);
  }

  // =========================
  // UI / SAFE CROP ZONE
  // =========================
  function buildSafeUI(){
    const baseY = GAME_H + 14; // –≤—Å—è –ø–∞–Ω–µ–ª—å –Ω–∏–∂–µ –ª–∏–Ω–∏–∏ crop

    // —Ñ–æ–Ω –ø–∞–Ω–µ–ª–∏
    const g = s.add.graphics();
    g.fillStyle(0x000000, 0.18);
    g.fillRect(0, GAME_H, W, SAFE_CROP_H);

    // BET - + (–º–∞–ª–µ–Ω—å–∫–∏–µ)
    btnMinus = makeBtn(W/2 - 120, baseY+18, 34, 26, "-", () => setBet(bet - BET_STEP));
    btnPlus  = makeBtn(W/2 + 120, baseY+18, 34, 26, "+", () => setBet(bet + BET_STEP));

    const bg = s.add.graphics();
    bg.fillStyle(0xffffff, 0.55);
    bg.fillRect(W/2-70, baseY+5, 140, 26);
    bg.lineStyle(2, 0x000000, 0.18);
    bg.strokeRect(W/2-70, baseY+5, 140, 26);

    betText = s.add.text(W/2, baseY+18, `BET: ${bet}`, {
      fontFamily:"monospace", fontSize:"12px", color:"#0b0b0b", fontStyle:"bold"
    }).setOrigin(0.5);

    // START
    btnStart = makeBtn(W/2, baseY+52, 170, 30, "–°–¢–ê–†–¢", () => startBonus());
  }

  function lockUI(lock){
    if(lock){
      btnStart.disableInteractive();
      btnMinus.disableInteractive();
      btnPlus.disableInteractive();
    } else {
      btnStart.setInteractive();
      btnMinus.setInteractive();
      btnPlus.setInteractive();
    }
  }

  function setBet(v){
    if(running) return;
    bet = clamp(v, BET_MIN, BET_MAX);
    bet = Math.round(bet / BET_STEP) * BET_STEP;
    betText.setText(`BET: ${bet}`);
  }

  // =========================
  // SLAB (–∏—Ç–æ–≥) + FREE SPIN LABEL
  // =========================
  function buildSlab(){
    const g = s.add.graphics();
    g.fillStyle(0xbdbdbd, 1);
    g.fillRect(24, SLAB_Y, W-48, 30);
    g.lineStyle(2, 0x6b6b6b, 1);
    g.strokeRect(24, SLAB_Y, W-48, 30);

    slabText = s.add.text(W/2, SLAB_Y+7, "0.00", {
      fontFamily:"monospace", fontSize:"16px", color:"#0b0b0b", fontStyle:"bold"
    }).setOrigin(0.5,0);

    fsText = s.add.text(28, SLAB_Y-8, "", {
      fontFamily:"monospace", fontSize:"12px", color:"rgba(0,0,0,.55)", fontStyle:"bold"
    }).setOrigin(0,1);
  }

  function setTotal(v){
    total = Math.max(0, v);
  }

  // =========================
  // OVERLAY (BLOCK BONUS 4 FREE SPINS)
  // =========================
  function buildOverlay(){
    const c = s.add.container(0,0).setDepth(999).setVisible(false);
    const dim = s.add.rectangle(W/2, GAME_H/2, W, GAME_H, 0x000000, 0.65);

    const title = s.add.text(W/2, GAME_H/2 - 30, "BLOCK BONUS", {
      fontFamily:"monospace", fontSize:"22px", color:"#ffffff", fontStyle:"bold"
    }).setOrigin(0.5);

    const big = s.add.text(W/2, GAME_H/2, `${FREE_SPINS} FREE SPINS`, {
      fontFamily:"monospace", fontSize:"26px", color:"#ffffff", fontStyle:"bold"
    }).setOrigin(0.5);

    const sub = s.add.text(W/2, GAME_H/2 + 32, "Blocks are persistent for 4 spins.", {
      fontFamily:"monospace", fontSize:"12px", color:"rgba(255,255,255,.75)", fontStyle:"bold"
    }).setOrigin(0.5);

    c.add([dim, title, big, sub]);

    c.show = () => { c.setVisible(true); c.setAlpha(0); s.tweens.add({targets:c, alpha:1, duration:180}); };
    c.hide = () => { s.tweens.add({targets:c, alpha:0, duration:180, onComplete:()=>c.setVisible(false)}); };
    return c;
  }

  // =========================
  // TOP (5x3)
  // =========================
  function buildTop(){
    topCells = [];
    for(let r=0;r<TOP.rows;r++){
      for(let c=0;c<TOP.cols;c++){
        const x = TOP.x + c*(TOP.cw+TOP.pad);
        const y = TOP.y + r*(TOP.ch+TOP.pad);
        topCells.push(makeTopCell(x,y,TOP.cw,TOP.ch,r,c));
      }
    }
  }

  function makeTopCell(x,y,w,h,r,c){
    const g = s.add.graphics();
    g.fillStyle(0xbfc5cc, 1);
    g.fillRect(x,y,w,h);
    g.lineStyle(2, 0x53575e, 1);
    g.strokeRect(x,y,w,h);

    const icon = s.add.text(x+w/2, y+h/2-2, "", {
      fontFamily:"monospace", fontSize:"18px", color:"#1a1a1a", fontStyle:"bold"
    }).setOrigin(0.5);

    const sub = s.add.text(x+w/2, y+h-10, "", {
      fontFamily:"monospace", fontSize:"10px", color:"#2d2d2d", fontStyle:"bold"
    }).setOrigin(0.5);

    return {x,y,w,h,r,c,g,icon,sub,sym:SYMS[0]};
  }

  function randomizeTop(forceOrb){
    topCells.forEach(cell=>{
      let sym;
      if(forceOrb && cell.r===0 && cell.c===2){
        sym = SYMS.find(z=>z.k==="ORB");
      } else {
        sym = pickWeighted([SYMS[0],SYMS[1],SYMS[2],SYMS[3]], [20,30,30,20]);
      }
      setTop(cell, sym);
    });
  }

  function setTop(cell, sym){
    cell.sym = sym;
    cell.icon.setText(sym.icon);
    cell.sub.setText(sym.sub);

    if(sym.k==="ORB"){
      cell.icon.setColor("#0b5cff");
      cell.sub.setColor("#0b5cff");
      pulseGlow(cell.x+cell.w/2, cell.y+cell.h/2, 16);
    } else {
      cell.icon.setColor("#1a1a1a");
      cell.sub.setColor("#2d2d2d");
    }
  }

  function reelSpin(){
    return new Promise(resolve=>{
      const t0 = s.time.now;
      const dur = 650;
      const ev = s.time.addEvent({
        delay: 55, loop:true,
        callback: ()=>{
          randomizeTop(false);
          topCells.forEach(c=> c.icon.y = (c.y + c.h/2 - 2) + rndi(-1,2));
          if(s.time.now - t0 >= dur){
            ev.remove(false);
            randomizeTop(true);
            topCells.forEach(c=> c.icon.y = (c.y + c.h/2 - 2));
            resolve();
          }
        }
      });
    });
  }

  // =========================
  // BLOCKS (5x6) persistent
  // =========================
  function buildBlocks(){
    blocks = [];
    for(let r=0;r<GRID.rows;r++){
      for(let c=0;c<GRID.cols;c++){
        const x = GRID.x + c*GRID.cw;
        const y = GRID.y + r*GRID.ch;
        const type = layerType(r,c);
        blocks.push(makeBlock(x,y,GRID.cw,GRID.ch,r,c,type));
      }
    }
    refreshHp();
  }

  function resetBlocksPersistent(){
    blocks.forEach(b=>{
      b.alive=true;
      b.type = layerType(b.r,b.c);
      b.hp = b.type.hp;
      b.g.clear();
      drawBlock(b.g, b.x,b.y,b.w,b.h,b.type);
      b.hpText.setAlpha(1);
    });
    refreshHp();
  }

  function layerType(r,c){
    if(r===0) return findType("GRASS");
    if(r===1) return findType("DIRT");
    if(r===2) return findType("STONE");
    if(r===3) return findType("RED");
    if(r===4) return (c<2 ? findType("DIAM") : findType("GOLD"));
    if(r===5) return (c===4 ? findType("OBSI") : pickWeighted(
      [findType("DIAM"), findType("GOLD"), findType("STONE")],
      [28, 45, 27]
    ));
    return findType("STONE");
  }

  function findType(k){ return BLOCK_TYPES.find(t=>t.key===k); }

  function makeBlock(x,y,w,h,r,c,type){
    const g = s.add.graphics();
    drawBlock(g,x,y,w,h,type);
    const hpText = s.add.text(x+4,y+4,"",{fontFamily:"monospace",fontSize:"10px",color:"rgba(0,0,0,.65)",fontStyle:"bold"});
    return {x,y,w,h,r,c,type,hp:type.hp,alive:true,g,hpText};
  }

  function drawBlock(g,x,y,w,h,type){
    g.fillStyle(type.base,1);
    g.fillRect(x,y,w,h);
    for(let i=0;i<10;i++){
      g.fillStyle(type.accent,0.9);
      g.fillRect(x+rndi(2,w-6), y+rndi(2,h-6), 2, 2);
    }
    g.lineStyle(2, 0x000000, 0.22);
    g.strokeRect(x,y,w,h);
    g.fillStyle(0xffffff, 0.10);
    g.fillRect(x+2,y+2,w-4,6);
    if(type.key==="GRASS"){
      g.fillStyle(0x56c83f,1);
      g.fillRect(x,y,w,10);
    }
    if(type.key==="RED"){
      g.fillStyle(0xb82e2e,1);
      g.fillRect(x,y+h-10,w,10);
    }
  }

  function refreshHp(){
    blocks.forEach(b => b.hpText.setText(b.alive ? `HP:${b.hp}` : ""));
  }

  function hitBlock(b){
    return new Promise(resolve=>{
      b.hp -= 1;
      pixelBurst(b.x+b.w/2, b.y+b.h/2, b.type.accent);

      const crack = s.add.graphics();
      crack.lineStyle(2, 0x000000, 0.22);
      crack.beginPath();
      crack.moveTo(b.x + rndi(6,b.w-6), b.y + rndi(6,b.h-6));
      crack.lineTo(b.x + rndi(6,b.w-6), b.y + rndi(6,b.h-6));
      crack.strokePath();
      s.time.delayedCall(120, ()=> crack.destroy());

      if(b.hp<=0){
        b.alive=false;

        // pay: –¥–æ–±–∞–≤–∫–∞ –∫–∞–∫ –≤ –≤–∏–¥–µ–æ (–Ω–∞–∫–∞–ø–ª–∏–≤–∞–µ–º –∫ –∏—Ç–æ–≥—É)
        const add = bet * b.type.pay;
        setTotal(total + add);

        s.time.delayedCall(80, ()=>{
          b.g.clear();
          b.g.fillStyle(0x000000, 0.06);
          b.g.fillRect(b.x,b.y,b.w,b.h);
          b.g.lineStyle(1, 0x000000, 0.12);
          b.g.strokeRect(b.x,b.y,b.w,b.h);
        });
        s.tweens.add({targets:b.hpText, alpha:0, duration:140});
      } else {
        b.hpText.setText(`HP:${b.hp}`);
      }
      s.time.delayedCall(130, resolve);
    });
  }

  // =========================
  // CHESTS (5 total, open 3..5)
  // =========================
  function buildChests(){
    chests = [];
    const startX = 28;
    const cw = 60;
    for(let i=0;i<CHESTS_TOTAL;i++){
      const x = startX + i*(cw+6);
      const y = CHEST_Y;
      chests.push(makeChest(x,y,cw,38,i));
    }
  }

  function makeChest(x,y,w,h,i){
    const g = s.add.graphics();
    drawChest(g,x,y,w,h,false);
    const lock = s.add.text(x+w/2, y+h/2+1, "üîí", {fontFamily:"monospace", fontSize:"12px"}).setOrigin(0.5);
    return {x,y,w,h,i,g,lock,opened:false};
  }

  function drawChest(g,x,y,w,h,opened){
    g.clear();
    g.fillStyle(0xc9903a,1);
    g.fillRect(x,y,w,h);
    g.fillStyle(0xa86e2c,1);
    g.fillRect(x,y,w,12);
    for(let k=0;k<4;k++){
      g.fillStyle(0x000000,0.10);
      g.fillRect(x+6+k*14, y, 2, h);
    }
    g.lineStyle(2,0x000000,0.22);
    g.strokeRect(x,y,w,h);
    if(opened){
      g.fillStyle(0x000000,0.18);
      g.fillRect(x, y-10, w, 10);
    }
  }

  function resetChests(){
    chests.forEach(c=>{
      c.opened=false;
      drawChest(c.g,c.x,c.y,c.w,c.h,false);
      c.lock.setText("üîí").setAlpha(1);
    });
  }

  // =========================
  // EFFECTS / DRAW
  // =========================
  function drawSky(){
    const bg = s.add.graphics();
    bg.fillStyle(0x6cc8ff,1);
    bg.fillRect(0,0,W,H);

    for(let i=0;i<8;i++){
      drawCloud(rndi(10,W-70), rndi(10,150), rndi(20,34));
    }

    const g = s.add.graphics();
    g.fillStyle(0x56c83f,1);
    g.fillRect(0, GAME_H-18, W, 8);
    g.fillStyle(0xb4723a,1);
    g.fillRect(0, GAME_H-10, W, 10);
    g.fillStyle(0x000000,0.12);
    g.fillRect(0, GAME_H-18, W, 18);
  }

  function drawCloud(x,y,size){
    const g = s.add.graphics();
    g.fillStyle(0xffffff, 1);
    g.fillRect(x, y, size, size/2);
    g.fillRect(x+8, y-6, size, size/2);
    g.fillRect(x+16, y+2, size, size/2);
    g.fillStyle(0x000000, 0.08);
    g.fillRect(x, y+size/2-2, size+16, 3);
  }

  function drawFrame(x,y,w,h){
    const g = s.add.graphics();
    g.fillStyle(0xd6d6d6,1);
    g.fillRect(x,y,w,h);
    g.lineStyle(3, 0x6b6b6b, 1);
    g.strokeRect(x,y,w,h);
    g.lineStyle(1, 0xffffff, 0.35);
    g.strokeRect(x+2,y+2,w-4,h-4);
  }

  function makeBtn(x,y,w,h,text,onClick){
    const c = s.add.container(x,y);
    const g = s.add.graphics();
    const draw = (pressed=false)=>{
      g.clear();
      g.fillStyle(0xb7b7b7, 1);
      g.fillRect(-w/2, -h/2, w, h);
      g.fillStyle(0x8f8f8f, 1);
      g.fillRect(-w/2, -h/2, w, 6);
      g.fillStyle(0xd7d7d7, 1);
      g.fillRect(-w/2, h/2-6, w, 6);
      g.lineStyle(2, 0x3a3a3a, 1);
      g.strokeRect(-w/2, -h/2, w, h);
      if(pressed){
        g.fillStyle(0x000000, 0.10);
        g.fillRect(-w/2, -h/2, w, h);
      }
    };
    draw(false);
    const t = s.add.text(0,0,text,{fontFamily:"monospace",fontSize:"14px",color:"#101010",fontStyle:"bold"}).setOrigin(0.5);
    c.add([g,t]);
    c.setSize(w,h);
    c.setInteractive(new Phaser.Geom.Rectangle(-w/2,-h/2,w,h), Phaser.Geom.Rectangle.Contains);
    c.on("pointerdown", ()=>{ draw(true); s.time.delayedCall(90, ()=>draw(false)); onClick(); });
    return c;
  }

  function pixelBurst(x,y,color){
    for(let i=0;i<10;i++){
      const p = s.add.rectangle(x,y,2,2,color,1);
      const dx = rnd(-30,30);
      const dy = rnd(-30,30);
      s.tweens.add({
        targets:p, x:x+dx, y:y+dy,
        alpha:{from:1,to:0},
        duration:260,
        onComplete:()=>p.destroy()
      });
    }
  }

  function pulseGlow(x,y,r){
    const g = s.add.graphics();
    g.fillStyle(0x2aa8ff, 0.35);
    g.fillCircle(x,y,r);
    s.tweens.add({targets:g, alpha:{from:0.45,to:0.1}, duration:500, yoyo:true, repeat:2, onComplete:()=>g.destroy()});
  }

  // =========================
  // UTILS
  // =========================
  function wait(ms){ return new Promise(r=>s.time.delayedCall(ms,r)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function rndi(a,b){ return Math.floor(rnd(a,b)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }

  function pickWeighted(values, weights){
    const sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random()*sum;
    for(let i=0;i<values.length;i++){
      r -= weights[i];
      if(r<=0) return values[i];
    }
    return values[values.length-1];
  }

  function fmt(v){
    const x = Math.max(0, v);
    return x.toFixed(DECIMALS); // —Ç–æ—á–∫–∞ –≤—Å–µ–≥–¥–∞
  }

  function makeNice(v){
    let x = Math.max(0, v);
    const step = x < 10 ? 0.1 : x < 100 ? 0.5 : x < 1000 ? 1 : x < 10000 ? 5 : 10;
    x = Math.ceil(x/step)*step;
    return Number(x.toFixed(DECIMALS));
  }

})();
</script>
</body>
</html>
