<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Block Bonus ‚Äì Your Style</title>

  <!-- –ü–∏–∫—Å–µ–ª—å–Ω—ã–π —à—Ä–∏—Ñ—Ç (–ø–æ—Ö–æ–∂ –Ω–∞ —Ç–≤–æ–π –∏–∑ –≤–∏–¥–µ–æ) -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap');
    html,body{height:100%;margin:0;background:#79d0ff;overflow:hidden}
    #wrap{height:100%;display:flex;align-items:center;justify-content:center;padding:10px}
    canvas{
      image-rendering:pixelated;
      image-rendering:crisp-edges;
      border-radius:18px;
      box-shadow:0 30px 90px rgba(0,0,0,.35);
      outline:2px solid rgba(0,0,0,.25);
      background:#79d0ff;
    }
  </style>

  <script src="https://cdn.jsdelivr.net/npm/phaser@3.80.1/dist/phaser.min.js"></script>
</head>
<body><div id="wrap"></div>

<script>
(() => {
  // ===== –¢–í–û–ò –£–°–õ–û–í–ò–Ø =====
  const FREE_SPINS = 4;
  const CHESTS_TOTAL = 5;
  const OPEN_MIN = 3, OPEN_MAX = 5;         // –æ—Ç–∫—Ä—ã–≤–∞–µ—Ç—Å—è 3..5
  const DECIMALS = 2;                        // –∏—Ç–æ–≥ 3270.00 (—Ç–æ—á–∫–∞)
  const BET_MIN = 10, BET_MAX = 5000, BET_STEP = 10; // –≤—ã–±–æ—Ä —Å—Ç–∞–≤–∫–∏, –±–µ–∑ –≤–∞–ª—é—Ç—ã

  // ===== CANVAS (9:16) =====
  const W = 360, H = 640;

  // ===== LAYOUT –∫–∞–∫ –Ω–∞ —Ç–≤–æ—ë–º –≤–∏–¥–µ–æ =====
  const PANEL_TOP = { x: 64, y: 26, w: 232, h: 128, cols:5, rows:3 };
  const TOWER = { x: 120, y: 176, colW: 24, rowH: 24, cols: 5, maxH: 10 }; // ‚Äú–±–∞—à–Ω—è‚Äù –∫–æ–º–ø–∞–∫—Ç–∏—Ç—Å—è –≤–Ω–∏–∑
  const CHEST = { y: 500, w: 44, h: 44, gap: 6, startX: 60 };
  const SLAB = { x: 86, y: 560, w: 188, h: 32 };

  // ===== GAME FEEL / TIMINGS =====
  const REEL_SPIN_MS = 650;
  const OVERLAY_MS = 900;
  const BETWEEN_SPINS_MS = 240;
  const HIT_DELAY_MS = 110;
  const CHEST_STEP_MS = 420;

  // ===== SYMBOLS (—Ç–≤–æ–∏ –∏–∑ –≤–∏–¥–µ–æ: –∫–∏—Ä–∫–∏ + TNT) =====
  const SYMS = [
    { k:"P1", hits:1 },
    { k:"P2", hits:2 },
    { k:"P3", hits:3 },
    { k:"TNT", hits:5 }, // ‚Äú—Å–∏–ª–æ–≤–æ–π‚Äù —Å–∏–º–≤–æ–ª –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
  ];

  // ===== BLOCK TYPES (–≤–∏–∑—É–∞–ª—å–Ω–æ –∫–∞–∫ –≤ —Ä–æ–ª–∏–∫–µ) =====
  const BLOCKS = {
    STONE: { key:"STONE", hp:1, pay:0.15, base:0xd8d8d8, speck:0xa7a7a7 },
    RED:   { key:"RED",   hp:1, pay:0.30, base:0xdedede, speck:0xc93a3a },
    DIAM:  { key:"DIAM",  hp:1, pay:0.70, base:0x57e9ff, speck:0x2fb9d2 },
    GOLD:  { key:"GOLD",  hp:1, pay:0.55, base:0xffd85a, speck:0xeab021 },
    OBSI:  { key:"OBSI",  hp:2, pay:1.50, base:0x1c1630, speck:0x2f2850 },
  };

  // —Å—Ç–∞—Ä—Ç–æ–≤–∞—è ‚Äú—Å—Ä–µ–∑–∫–∞‚Äù –±–∞—à–Ω–∏ –∫–∞–∫ –≤ –≤–∏–¥–µ–æ (–Ω–µ –ø–æ–ª–Ω–∞—è 5xN, –∞ —Å—Ç—É–ø–µ–Ω—å–∫–∞–º–∏)
  const START_HEIGHTS = [6,5,6,5,6]; // –º–æ–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å, –Ω–æ —ç—Ç–æ –ø–æ—Ö–æ–∂–µ –ø–æ —Ä–æ–ª–∏–∫—É

  // ===== Phaser =====
  new Phaser.Game({
    type: Phaser.AUTO,
    parent: "wrap",
    width: W,
    height: H,
    backgroundColor: "#79d0ff",
    pixelArt: true,
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    scene: { create, update }
  });

  // ===== STATE =====
  let s;
  let running = false;
  let recMode = false;

  let bet = 100;
  let total = 0, totalDisp = 0;
  let spinIdx = 0;

  // top panel cells
  let panelCells = []; // 5x3
  let panelGraphics;

  // tower (5 columns, each is stack bottom->top)
  let towerCols = [];  // [{blocks:[...]}]
  let towerSprites = []; // sprites for redraw

  // chests
  let chests = [];

  // UI / texts
  let slabText, fsText;
  let overlayC;
  let uiC; // bet/start (can hide)

  // floating win texts
  let floatTexts = [];

  function create(){
    s = this;

    drawSky();
    drawGround();

    drawTopPanel();
    buildTopCells();

    initTower();
    redrawTower(true);

    buildChests();
    drawSlab();
    buildOverlay();
    buildUI();
    setupRECControls();

    setTotal(0);
    randomizePanel(true);
  }

  function update(){
    totalDisp += (total - totalDisp) * 0.18;
    if (Math.abs(total-totalDisp) < 0.005) totalDisp = total;
    slabText.setText(fmt(totalDisp));
  }

  // =============================
  // FLOW (–∫–∞–∫ –≤ —Ç–≤–æ—ë–º –≤–∏–¥–µ–æ)
  // =============================
  async function startBonus(){
    if (running) return;
    running = true;
    lockUI(true);

    spinIdx = 0;
    setTotal(0);
    resetChests();
    initTower();
    redrawTower(true);

    overlayC.show();
    await wait(OVERLAY_MS);
    overlayC.hide();
    await wait(240);

    for(let i=0;i<FREE_SPINS;i++){
      spinIdx = i+1;
      fsText.setText(`FREE SPIN ${spinIdx}/${FREE_SPINS}`);
      await doSpin();
      await wait(BETWEEN_SPINS_MS);
    }
    fsText.setText("");

    await doChestPhase();

    running = false;
    lockUI(false);
  }

  async function doSpin(){
    await reelSpin();

    // hits per column from top panel
    const hits = [0,0,0,0,0];
    panelCells.forEach(cell => {
      hits[cell.c] += cell.sym.hits;
    });

    // —á—Ç–æ–±—ã –±—ã–ª–æ ‚Äú—Å–æ—á–Ω–æ‚Äù –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
    for(let i=0;i<5;i++) hits[i] += rndi(0,2);

    // apply hits: –ª–æ–º–∞–µ–º –≤–µ—Ä—Ö–Ω–∏–π –±–ª–æ–∫ –≤ –∫–æ–ª–æ–Ω–∫–µ, –ø–æ–∫–∞ –µ—Å—Ç—å hits
    for(let c=0;c<5;c++){
      let left = hits[c];
      while(left > 0){
        const got = hitTopBlockInColumn(c);
        if(!got) break;
        left--;
        await wait(HIT_DELAY_MS);
      }
    }

    redrawTower(false);
  }

  function hitTopBlockInColumn(col){
    const stack = towerCols[col].blocks;
    if(stack.length === 0) return false;

    // –±—å—ë–º –≤–µ—Ä—Ö–Ω–∏–π
    const b = stack[stack.length - 1];
    b.hp -= 1;

    // —á–∞—Å—Ç–∏—Ü—ã
    const p = blockToWorld(col, stack.length-1);
    burst(p.x, p.y, b.type.speck);

    if(b.hp <= 0){
      stack.pop(); // —Ä–∞–∑—Ä—É—à–∏–ª–∏
      const add = bet * b.type.pay;
      setTotal(total + add);
      floatWin(p.x, p.y - 10, add);
      return true;
    }
    return true;
  }

  async function doChestPhase(){
    // 3..5 —Å—É–Ω–¥—É–∫–æ–≤
    const openCount = rndi(OPEN_MIN, OPEN_MAX+1);

    // —á–µ–º –º–µ–Ω—å—à–µ —Å—É–Ω–¥—É–∫–æ–≤, —Ç–µ–º –≤—ã—à–µ –º–Ω–æ–∂–∏—Ç–µ–ª–∏
    const pool = (openCount === 3)
      ? {v:[5,10,12,15,20,25,30,40,50], w:[6,14,14,14,14,12,10,8,8]}
      : (openCount === 4)
      ? {v:[2,3,5,8,10,12,15,20,25], w:[18,16,16,14,12,10,8,4,2]}
      : {v:[2,2,3,3,5,5,8,10,12], w:[22,20,16,14,12,8,5,2,1]};

    // –í —Ç–≤–æ—ë–º —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –∫–∞–¥—Ä–µ —Ü–µ–Ω—Ç—Ä –±—ã–ª –∑–∞–∫—Ä—ã—Ç ‚Äî –¥–µ–ª–∞–µ–º —Ç–∞–∫:
    // –µ—Å–ª–∏ –æ—Ç–∫—Ä—ã–≤–∞–µ–º 3‚Äì4 —Å—É–Ω–¥—É–∫–∞, –æ—Å—Ç–∞–≤–∏–º —Ü–µ–Ω—Ç—Ä –∑–∞–∫—Ä—ã—Ç—ã–º —á–∞—â–µ.
    const order = [0,1,3,4,2]; // –æ—Ç–∫—Ä—ã–≤–∞–µ–º —Å–ª–µ–≤–∞ –Ω–∞–ø—Ä–∞–≤–æ, —Ü–µ–Ω—Ç—Ä –ø–æ—Å–ª–µ–¥–Ω–∏–º
    let opened = 0;
    let cur = total;

    for(const idx of order){
      if(opened >= openCount) break;

      // –µ—Å–ª–∏ —ç—Ç–æ —Ü–µ–Ω—Ç—Ä (2) –∏ openCount < 5 ‚Äî —Å —à–∞–Ω—Å–æ–º –ø—Ä–æ–ø—É—Å–∫–∞–µ–º, —á—Ç–æ–±—ã –±—ã–ª ‚Äú—Ü–µ–Ω—Ç—Ä –∑–∞–∫—Ä—ã—Ç‚Äù
      if(idx === 2 && openCount < 5 && Math.random() < 0.75){
        continue;
      }

      const mul = pickW(pool.v, pool.w);
      openChest(idx);
      showMul(idx, mul);

      cur = cur * mul;
      setTotal(cur);

      opened++;
      await wait(CHEST_STEP_MS);
    }

    // –µ—Å–ª–∏ –≤–¥—Ä—É–≥ –æ—Ç–∫—Ä—ã–ª–∏ –º–µ–Ω—å—à–µ –Ω—É–∂–Ω–æ–≥–æ (–∏–∑-–∑–∞ –ø—Ä–æ–ø—É—Å–∫–∞ —Ü–µ–Ω—Ç—Ä–∞) ‚Äî –¥–æ–±—å—ë–º –∫—Ä–∞–π–Ω–∏–º–∏
    if(opened < openCount){
      for(const idx of [0,4,1,3,2]){
        if(opened >= openCount) break;
        if(chests[idx].open) continue;
        const mul = pickW(pool.v, pool.w);
        openChest(idx);
        showMul(idx, mul);
        cur = cur * mul;
        setTotal(cur);
        opened++;
        await wait(CHEST_STEP_MS);
      }
    }

    setTotal(makeNice(cur));
    await wait(300);
  }

  // =============================
  // VISUALS (–∫–∞–∫ –Ω–∞ –≤–∏–¥–µ–æ)
  // =============================
  function drawSky(){
    // —á–∏—Å—Ç–æ–µ –Ω–µ–±–æ + –æ–±–ª–∞–∫–∞ –∫–∞–∫ ‚Äú–ø–ª–∞—à–∫–∏‚Äù
    s.add.rectangle(W/2, H/2, W, H, 0x79d0ff).setDepth(-50);

    for(let i=0;i<8;i++){
      cloud(rndi(10, W-70), rndi(20, 200), rndi(22, 40));
    }
  }

  function cloud(x,y,size){
    const g = s.add.graphics().setDepth(-40);
    g.fillStyle(0xffffff, 1);
    g.fillRect(x,y,size,size/2);
    g.fillRect(x+10,y-6,size,size/2);
    g.fillRect(x+22,y+2,size,size/2);
    g.fillStyle(0x000000, 0.06);
    g.fillRect(x, y+size/2-2, size+22, 3);
  }

  function drawGround(){
    // –∑–µ–ª—ë–Ω–∞—è –ø–æ–ª–æ—Å–∞ + –∫–æ—Ä–∏—á–Ω–µ–≤–∞—è –∑–µ–º–ª—è –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
    const g = s.add.graphics().setDepth(-30);
    g.fillStyle(0x5fd23f,1);
    g.fillRect(0, 520, W, 14);
    g.fillStyle(0xb8743c,1);
    g.fillRect(0, 534, W, 106);

    // –ª—ë–≥–∫–∞—è —Ç–µ–Ω—å
    g.fillStyle(0x000000, 0.08);
    g.fillRect(0, 520, W, 120);
  }

  function drawTopPanel(){
    // –±–æ–ª—å—à–∞—è —Ä–∞–º–∫–∞ + –≤–Ω—É—Ç—Ä–µ–Ω–Ω–∏–µ –ª–∏–Ω–∏–∏
    const {x,y,w,h,cols,rows} = PANEL_TOP;

    panelGraphics = s.add.graphics();

    // –≤–Ω–µ—à–Ω—è—è —Ä–∞–º–∫–∞
    panelGraphics.fillStyle(0xd0d0d0,1);
    panelGraphics.fillRect(x,y,w,h);
    panelGraphics.lineStyle(3, 0x6b6b6b, 1);
    panelGraphics.strokeRect(x,y,w,h);
    panelGraphics.lineStyle(2, 0x8d8d8d, 1);
    panelGraphics.strokeRect(x+2,y+2,w-4,h-4);

    // –∫–ª–µ—Ç–∫–∏
    const cw = Math.floor(w/cols);
    const ch = Math.floor(h/rows);

    panelGraphics.lineStyle(2, 0xffffff, 0.9);
    for(let c=1;c<cols;c++){
      panelGraphics.beginPath();
      panelGraphics.moveTo(x+c*cw, y+6);
      panelGraphics.lineTo(x+c*cw, y+h-6);
      panelGraphics.strokePath();
    }
    for(let r=1;r<rows;r++){
      panelGraphics.beginPath();
      panelGraphics.moveTo(x+6, y+r*ch);
      panelGraphics.lineTo(x+w-6, y+r*ch);
      panelGraphics.strokePath();
    }
  }

  function buildTopCells(){
    panelCells = [];
    const {x,y,w,h,cols,rows} = PANEL_TOP;
    const cw = Math.floor(w/cols);
    const ch = Math.floor(h/rows);

    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cx = x + c*cw;
        const cy = y + r*ch;

        const icon = s.add.container(cx+cw/2, cy+ch/2);
        panelCells.push({r,c,cx,cy,cw,ch,icon,sym:SYMS[0]});
      }
    }
  }

  function randomizePanel(forceTNT){
    panelCells.forEach(cell=>{
      // —á–∞—â–µ –∫–∏—Ä–∫–∏, –∏–Ω–æ–≥–¥–∞ TNT
      const sym = forceTNT && cell.r===0 && cell.c===1
        ? SYMS.find(z=>z.k==="TNT")
        : pickW([SYMS[0],SYMS[1],SYMS[2],SYMS[3]],[26,30,28,16]);
      cell.sym = sym;
      drawPanelIcon(cell);
    });
  }

  function drawPanelIcon(cell){
    cell.icon.removeAll(true);

    if(cell.sym.k === "TNT"){
      // TNT sprite-like
      const g = s.add.graphics();
      g.fillStyle(0xd83b3b,1);
      g.fillRect(-14,-14,28,28);
      g.fillStyle(0xffffff,1);
      g.fillRect(-14,2,28,10);
      g.lineStyle(2,0x000000,0.35);
      g.strokeRect(-14,-14,28,28);

      const t = pixelText("TNT", 0, 7, 8, "#000");
      t.setOrigin(0.5,0.5);

      cell.icon.add([g,t]);
      return;
    }

    // Pickaxe: —Ä–∏—Å—É–µ–º –ø–∏–∫—Å–µ–ª—å-–ø–∏–∫
    const pick = drawPickaxe();
    cell.icon.add(pick);

    // –º–∞–ª–µ–Ω—å–∫–∞—è —Ü–∏—Ñ—Ä–∞ ‚Äú1/2/3‚Äù –≤ —É–≥–ª—É –∫–∞–∫ –Ω–∞ –≤–∏–¥–µ–æ
    const n = String(cell.sym.hits);
    const num = pixelText(n, 14, -12, 10, "#ffffff");
    // —á—ë—Ä–Ω–∞—è –æ–±–≤–æ–¥–∫–∞ (–¥–≤–æ–π–Ω–æ–π —Ç–µ–∫—Å—Ç)
    const numShadow = pixelText(n, 15, -11, 10, "#000000");
    numShadow.setAlpha(0.55);

    cell.icon.add([numShadow, num]);
  }

  function drawPickaxe(){
    const g = s.add.graphics();
    // —Ä—É—á–∫–∞
    g.fillStyle(0x8b5a2b,1);
    g.fillRect(-2,-10,4,22);
    // ‚Äú–º–µ—Ç–∞–ª–ª‚Äù
    g.fillStyle(0x7a7a7a,1);
    g.fillRect(-12,-10,24,5);
    // –∫–æ–Ω—Ç—É—Ä
    g.lineStyle(2,0x000000,0.30);
    g.strokeRect(-2,-10,4,22);
    g.strokeRect(-12,-10,24,5);
    return g;
  }

  // =============================
  // TOWER (–∫–æ–ª–æ–Ω–∫–∏ + –ø–∞–¥–µ–Ω–∏–µ)
  // =============================
  function initTower(){
    towerCols = [];
    for(let c=0;c<5;c++){
      const h = START_HEIGHTS[c];
      const arr = [];
      for(let i=0;i<h;i++){
        // –≤–µ—Ä—Ö–Ω–∏–µ –±–æ–ª—å—à–µ stone/red, –Ω–∏–∂–µ gold/diam
        const type = pickStartType(i);
        arr.push({type, hp:type.hp});
      }
      towerCols.push({blocks: arr});
    }
  }

  function pickStartType(level){
    // 0 = –Ω–∏–∑, –≤—ã—à–µ = –±–ª–∏–∂–µ –∫ –≤–µ—Ä—Ö—É
    if(level >= 4) return Math.random() < 0.70 ? BLOCKS.STONE : BLOCKS.RED;
    if(level >= 2) return Math.random() < 0.50 ? BLOCKS.RED : BLOCKS.GOLD;
    return Math.random() < 0.55 ? BLOCKS.DIAM : BLOCKS.GOLD;
  }

  function redrawTower(full){
    // —á–∏—Å—Ç–∏–º —Å—Ç–∞—Ä—ã–µ
    if(full){
      towerSprites.forEach(o=>o.destroy());
      towerSprites = [];
    }else{
      // —á–∞—Å—Ç–∏—á–Ω–æ: –≤—Å—ë —Ä–∞–≤–Ω–æ –ø—Ä–æ—â–µ –ø–µ—Ä–µ—Ä–∏—Å–æ–≤–∞—Ç—å (–æ–±—ä–µ–∫—Ç–æ–≤ –º–∞–ª–æ)
      towerSprites.forEach(o=>o.destroy());
      towerSprites = [];
    }

    for(let c=0;c<5;c++){
      const stack = towerCols[c].blocks;
      for(let i=0;i<stack.length;i++){
        const b = stack[i];
        const p = blockToWorld(c,i);
        const spr = drawBlockSprite(p.x, p.y, b.type);
        towerSprites.push(spr);
      }
    }
  }

  function blockToWorld(col, idx){
    const baseX = TOWER.x + col*TOWER.colW;
    const baseY = TOWER.y + 300; // ‚Äú–ø–æ–ª–∫–∞‚Äù –±–∞—à–Ω–∏
    const x = baseX;
    const y = baseY - idx*TOWER.rowH;
    return {x,y};
  }

  function drawBlockSprite(x,y,t){
    const g = s.add.graphics();
    // 24x24 –±–ª–æ–∫ —Å —á—ë—Ä–Ω–æ–π —Ä–∞–º–∫–æ–π
    g.fillStyle(t.base,1);
    g.fillRect(x, y, 24, 24);

    // –¥–∏–∞–≥–æ–Ω–∞–ª—å–Ω—ã–π –±–ª–∏–∫ –¥–ª—è –∑–æ–ª–æ—Ç–∞
    if(t.key==="GOLD"){
      g.fillStyle(0xffffff,0.18);
      g.fillRect(x+2,y+2,8,20);
      g.fillRect(x+12,y+2,6,20);
    }

    // —Ä–µ–¥—Å—Ç–æ—É–Ω-–ø—è—Ç–Ω–∞
    if(t.key==="RED"){
      g.fillStyle(t.speck,1);
      g.fillRect(x+3,y+4,4,3);
      g.fillRect(x+10,y+8,5,4);
      g.fillRect(x+15,y+3,4,3);
      g.fillRect(x+6,y+15,5,4);
    } else {
      // speck noise
      g.fillStyle(t.speck,1);
      for(let i=0;i<5;i++){
        g.fillRect(x+rndi(2,20), y+rndi(2,20), 2, 2);
      }
    }

    // outline
    g.lineStyle(2, 0x000000, 0.32);
    g.strokeRect(x, y, 24, 24);

    return g;
  }

  // =============================
  // CHESTS (–∫–∞–∫ –≤ —Ñ–∏–Ω–∞–ª—å–Ω–æ–º –∫–∞–¥—Ä–µ)
  // =============================
  function buildChests(){
    chests = [];
    for(let i=0;i<CHESTS_TOTAL;i++){
      const x = CHEST.startX + i*(CHEST.w + CHEST.gap);
      const c = {
        x, y: CHEST.y, open:false,
        base: s.add.graphics(),
        lock: null,
        lid: null
      };
      chests.push(c);
      drawChest(i, false);
    }
  }

  function resetChests(){
    chests.forEach((c,i)=> drawChest(i,false));
  }

  function openChest(i){
    drawChest(i,true);
  }

  function drawChest(i, open){
    const c = chests[i];
    c.open = open;
    c.base.clear();

    // –∫–æ—Ä–ø—É—Å
    c.base.fillStyle(0xc9903a,1);
    c.base.fillRect(c.x, c.y, CHEST.w, CHEST.h);
    // –≤–µ—Ä—Ö–Ω—è—è –ø–ª–∞–Ω–∫–∞
    c.base.fillStyle(0xa86e2c,1);
    c.base.fillRect(c.x, c.y, CHEST.w, 10);

    // ‚Äú–¥–æ—Å–∫–∏‚Äù
    c.base.fillStyle(0x000000,0.12);
    c.base.fillRect(c.x+10, c.y, 2, CHEST.h);
    c.base.fillRect(c.x+22, c.y, 2, CHEST.h);
    c.base.fillRect(c.x+34, c.y, 2, CHEST.h);

    // outline
    c.base.lineStyle(2,0x000000,0.30);
    c.base.strokeRect(c.x, c.y, CHEST.w, CHEST.h);

    // –∫—Ä—ã—à–∫–∞ (–æ—Ç–∫—Ä—ã—Ç–∞)
    if(open){
      c.base.fillStyle(0x000000,0.10);
      c.base.fillRect(c.x, c.y-10, CHEST.w, 10);
      // ‚Äú–ø–µ—Ç–ª–∏‚Äù –±–µ–ª—ã–µ –∫–∞–∫ –≤ –≤–∏–¥–µ–æ
      c.base.fillStyle(0xffffff,1);
      c.base.fillRect(c.x+6, c.y-10, 6, 4);
      c.base.fillRect(c.x+CHEST.w-12, c.y-10, 6, 4);
    }

    // –∑–∞–º–æ–∫ (–µ—Å–ª–∏ –∑–∞–∫—Ä—ã—Ç)
    if(!open){
      if(!c.lock){
        c.lock = s.add.text(c.x+CHEST.w/2, c.y+CHEST.h/2+2, "üîí", {
          fontFamily:"monospace", fontSize:"12px"
        }).setOrigin(0.5);
      }
      c.lock.setVisible(true);
      c.lock.setPosition(c.x+CHEST.w/2, c.y+CHEST.h/2+2);
    }else{
      if(c.lock) c.lock.setVisible(false);
    }
  }

  function showMul(i, mul){
    const c = chests[i];
    const txt = pixelText(`x${mul}`, c.x+CHEST.w/2, c.y-14, 12, "#0b0b0b");
    txt.setOrigin(0.5);

    // –±–µ–ª–∞—è –ø–æ–¥–ª–æ–∂–∫–∞
    const pad = s.add.graphics();
    pad.fillStyle(0xffffff, 0.65);
    const w = 44, h = 16;
    pad.fillRect(c.x+CHEST.w/2 - w/2, c.y-22, w, h);
    pad.lineStyle(2,0x000000,0.20);
    pad.strokeRect(c.x+CHEST.w/2 - w/2, c.y-22, w, h);

    // bounce
    s.tweens.add({targets:[pad,txt], y: '-=10', duration:180, yoyo:true});
    s.tweens.add({
      targets:[pad,txt],
      alpha:0,
      duration:520,
      delay:780,
      onComplete:()=>{ pad.destroy(); txt.destroy(); }
    });

    burst(c.x+CHEST.w/2, c.y+8, 0xffd85a);
  }

  // =============================
  // SLAB (—Å–µ—Ä—ã–π –ø—Ä—è–º–æ—É–≥–æ–ª—å–Ω–∏–∫ + –∫—Ä—É–ø–Ω—ã–π –∏—Ç–æ–≥)
  // =============================
  function drawSlab(){
    const g = s.add.graphics();
    g.fillStyle(0xbdbdbd,1);
    g.fillRect(SLAB.x, SLAB.y, SLAB.w, SLAB.h);
    g.lineStyle(2,0x6b6b6b,1);
    g.strokeRect(SLAB.x, SLAB.y, SLAB.w, SLAB.h);

    // drop shadow panel (–∫–∞–∫ –≤ –≤–∏–¥–µ–æ)
    g.fillStyle(0x000000,0.12);
    g.fillRect(SLAB.x+2, SLAB.y+SLAB.h-4, SLAB.w-4, 4);

    // –∫—Ä—É–ø–Ω—ã–µ —Ü–∏—Ñ—Ä—ã —Å –æ–±–≤–æ–¥–∫–æ–π
    slabText = outlinedText("0.00", W/2, SLAB.y+SLAB.h/2+1, 16);

    fsText = pixelText("", SLAB.x-52, SLAB.y-10, 10, "rgba(0,0,0,.55)");
    fsText.setOrigin(0,1);
  }

  // =============================
  // OVERLAY (–∫–∞–∫ –Ω–∞ —Å—Ç–∞—Ä—Ç–µ —Ç–≤–æ–µ–≥–æ –≤–∏–¥–µ–æ)
  // =============================
  function buildOverlay(){
    overlayC = s.add.container(0,0).setDepth(500).setVisible(false);

    const dim = s.add.rectangle(W/2, H/2, W, H, 0x000000, 0.55);
    overlayC.add(dim);

    const t1 = outlinedText("BLOCK BONUS", W/2, H/2-46, 20);
    const t2 = outlinedText(`${FREE_SPINS} FREE SPINS`, W/2, H/2-6, 22);

    const sub = s.add.text(W/2, H/2+40, "Blocks are persistent for 4 spins.", {
      fontFamily: '"Press Start 2P", monospace',
      fontSize: "10px",
      color: "#ffffff"
    }).setOrigin(0.5);
    sub.setShadow(2,2,"rgba(0,0,0,.45)",0,true,true);

    overlayC.add([t1, t2, sub]);

    overlayC.show = () => {
      overlayC.setVisible(true);
      overlayC.setAlpha(0);
      s.tweens.add({targets:overlayC, alpha:1, duration:160});
    };
    overlayC.hide = () => {
      s.tweens.add({targets:overlayC, alpha:0, duration:160, onComplete:()=>overlayC.setVisible(false)});
    };
  }

  // =============================
  // UI (BET/START), –º–æ–∂–Ω–æ —Å–∫—Ä—ã—Ç—å REC
  // =============================
  function buildUI(){
    uiC = s.add.container(0,0).setDepth(600);

    const bg = s.add.graphics();
    bg.fillStyle(0x000000,0.18);
    bg.fillRect(0, H-42, W, 42);

    const minus = uiBtn(W/2-120, H-28, 32, 22, "-", ()=>setBet(bet-BET_STEP));
    const plus  = uiBtn(W/2+120, H-28, 32, 22, "+", ()=>setBet(bet+BET_STEP));

    const panel = s.add.graphics();
    panel.fillStyle(0xffffff,0.60);
    panel.fillRect(W/2-72, H-40, 144, 24);
    panel.lineStyle(2,0x000000,0.18);
    panel.strokeRect(W/2-72, H-40, 144, 24);

    const betT = s.add.text(W/2, H-28, `BET: ${bet}`, {
      fontFamily: '"Press Start 2P", monospace',
      fontSize: "10px",
      color: "#0b0b0b"
    }).setOrigin(0.5);

    const start = uiBtn(W/2, H-12, 180, 24, "START", ()=>startBonus());

    const hint = s.add.text(W-6, H-6, "R = REC", {
      fontFamily:'"Press Start 2P", monospace',
      fontSize:"8px",
      color:"rgba(255,255,255,.55)"
    }).setOrigin(1,1);

    uiC.add([bg, minus, plus, panel, betT, start, hint]);

    uiC.minus=minus; uiC.plus=plus; uiC.start=start; uiC.betText=betT;
  }

  function lockUI(lock){
    if(lock){
      uiC.start.disableInteractive();
      uiC.minus.disableInteractive();
      uiC.plus.disableInteractive();
    }else{
      uiC.start.setInteractive();
      uiC.minus.setInteractive();
      uiC.plus.setInteractive();
    }
  }

  function setBet(v){
    if(running) return;
    bet = clamp(v, BET_MIN, BET_MAX);
    bet = Math.round(bet/BET_STEP)*BET_STEP;
    uiC.betText.setText(`BET: ${bet}`);
  }

  // =============================
  // REC controls: R (–ü–ö) / triple tap (—Ç–µ–ª–µ—Ñ–æ–Ω)
  // =============================
  function setupRECControls(){
    s.input.keyboard?.on("keydown-R", ()=>toggleREC());
    s.input.keyboard?.on("keydown-SPACE", ()=>startBonus());
    s.input.keyboard?.on("keydown-ENTER", ()=>startBonus());

    let taps=0, last=0;
    s.input.on("pointerdown",(p)=>{
      // —Ç—Ä–æ–π–Ω–æ–π —Ç–∞–ø –≤ –ø—Ä–∞–≤–æ–º –≤–µ—Ä—Ö–Ω–µ–º —É–≥–ª—É
      if(p.x < W-60 || p.y > 60) return;
      const now = s.time.now;
      if(now-last > 450) taps=0;
      taps++; last=now;
      if(taps>=3){ taps=0; toggleREC(); }
    });
  }

  function toggleREC(){
    recMode = !recMode;
    uiC.setVisible(!recMode);
  }

  // =============================
  // Animations / FX
  // =============================
  function reelSpin(){
    return new Promise(resolve=>{
      const t0 = s.time.now;
      const ev = s.time.addEvent({
        delay: 55, loop: true,
        callback: ()=>{
          randomizePanel(false);
          if(s.time.now - t0 >= REEL_SPIN_MS){
            ev.remove(false);
            randomizePanel(true);
            resolve();
          }
        }
      });
    });
  }

  function floatWin(x,y, add){
    const txt = outlinedText(fmt(add), x+12, y, 12);
    txt.setDepth(400);
    s.tweens.add({
      targets: txt,
      y: y-18,
      alpha: 0,
      duration: 700,
      onComplete: ()=>txt.destroy()
    });
  }

  function burst(x,y,color){
    for(let i=0;i<10;i++){
      const p = s.add.rectangle(x,y,2,2,color,1).setDepth(300);
      s.tweens.add({
        targets:p,
        x: x + rnd(-24,24),
        y: y + rnd(-24,24),
        alpha:{from:1,to:0},
        duration:260,
        onComplete: ()=>p.destroy()
      });
    }
  }

  // =============================
  // Text helpers (–æ–±–≤–æ–¥–∫–∞ –∫–∞–∫ –≤ –≤–∏–¥–µ–æ)
  // =============================
  function pixelText(str, x,y, size, color){
    return s.add.text(x,y,String(str),{
      fontFamily: '"Press Start 2P", monospace',
      fontSize: `${size}px`,
      color: color
    });
  }

  function outlinedText(str, x,y, size){
    const c = s.add.container(x,y);
    const text = String(str);

    const shadow = s.add.text(2,2,text,{
      fontFamily:'"Press Start 2P", monospace',
      fontSize:`${size}px`,
      color:"#000000"
    }).setOrigin(0.5);

    const main = s.add.text(0,0,text,{
      fontFamily:'"Press Start 2P", monospace',
      fontSize:`${size}px`,
      color:"#ffffff"
    }).setOrigin(0.5);

    // –ª—ë–≥–∫–∏–π ‚Äúoutline‚Äù —á–µ—Ä–µ–∑ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —Ç–µ–Ω–∏
    main.setShadow(2,2,"rgba(0,0,0,.55)",0,true,true);

    c.add([shadow, main]);
    c.setSize(10,10);

    c.setText = (v)=>{
      const t = String(v);
      shadow.setText(t);
      main.setText(t);
    };

    return c;
  }

  // =============================
  // Utils
  // =============================
  function wait(ms){ return new Promise(r=>s.time.delayedCall(ms,r)); }
  function rnd(a,b){ return a + Math.random()*(b-a); }
  function rndi(a,b){ return Math.floor(rnd(a,b)); }
  function clamp(v,a,b){ return Math.max(a, Math.min(b,v)); }
  function fmt(v){ return Math.max(0,v).toFixed(DECIMALS); }
  function makeNice(v){
    let x=Math.max(0,v);
    const step = x<10?0.1:x<100?0.5:x<1000?1:x<10000?5:10;
    x=Math.ceil(x/step)*step;
    return Number(x.toFixed(DECIMALS));
  }
  function pickW(values, weights){
    const sum = weights.reduce((a,b)=>a+b,0);
    let r = Math.random()*sum;
    for(let i=0;i<values.length;i++){ r-=weights[i]; if(r<=0) return values[i]; }
    return values[values.length-1];
  }

})();
</script>
</body>
</html>
